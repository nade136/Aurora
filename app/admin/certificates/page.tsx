"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import * as XLSX from "xlsx";
import { getBrowserSupabase } from "@/lib/supabase/browser";
import { generateCertificateCode } from "@/lib/certificates/code";

const AURORA_PREFIX = "AURORA";

// helper: chunk array (module-level)
function chunkArray<T>(arr: T[], size: number): T[][] {
  const out: T[][] = [];
  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
  return out;
}

type StudentInput = {
  name: string;
  email: string;
  position: string;
  cohort: string;
  issuedAt: string; // yyyy-MM-dd
};

type StudentRow = StudentInput & {
  id: string;
  seq: number;
  status: "active" | "suspended";
  fileUrl?: string | null;
};

const defaultRow: StudentInput = {
  name: "Amaka Umeh",
  email: "amaka@example.com",
  position: "Robotics Engineer",
  cohort: "CORE2",
  issuedAt: new Date().toISOString().slice(0, 10),
};

export default function CertificatesAdminPage() {
  const [mode, setMode] = useState<"manual" | "auto">("manual");
  const [row, setRow] = useState<StudentInput>(() => {
    try {
      const v = typeof window !== 'undefined' ? window.localStorage.getItem('cert_manual_row') : null;
      if (v) {
        const parsed = JSON.parse(v) as Partial<StudentInput>;
        return {
          name: parsed.name || defaultRow.name,
          email: parsed.email || defaultRow.email,
          position: parsed.position || defaultRow.position,
          cohort: parsed.cohort || defaultRow.cohort,
          issuedAt: parsed.issuedAt || defaultRow.issuedAt,
        } as StudentInput;
      }
    } catch {}
    return defaultRow;
  });
  useEffect(() => {
    try { window.localStorage.setItem('cert_manual_row', JSON.stringify(row)); } catch {}
  }, [row]);
  // Sequence will be auto-generated by the system in batch; keep internal for preview only
  const [seq] = useState<number>(1);
  // Compose inputs
  const [subject, setSubject] = useState<string>(() => {
    try {
      const v = typeof window !== 'undefined' ? window.localStorage.getItem('cert_subject') : null;
      return v ?? "Certificate of Participation — Aurora Robotics Core Workshop 1.0";
    } catch { return "Certificate of Participation — Aurora Robotics Core Workshop 1.0"; }
  });
  const [body, setBody] = useState<string>(() => {
    const def = `Dear {{name}},\n\nThank you for being part of the Aurora Robotics\nCore Workshop 1.0. We appreciate your time,\ncommitment, and active participation \nthroughout the workshop.\n\nPlease find attached your Certificate of \nParticipation. We hope the experience was \ninsightful and that the skills gained will support\nyour learning and future projects.\n\nWarm regards,\nAurora Robotics.`;
    try {
      const v = typeof window !== 'undefined' ? window.localStorage.getItem('cert_body') : null;
      return v ?? def;
    } catch { return def; }
  });
  useEffect(() => {
    try { window.localStorage.setItem('cert_subject', subject); } catch {}
  }, [subject]);
  useEffect(() => {
    try { window.localStorage.setItem('cert_body', body); } catch {}
  }, [body]);
  // Track file names for display
  const [fileNames, setFileNames] = useState<Record<string, string>>({});

  // Recipient mode and data
  const [recipientMode, setRecipientMode] = useState<"bulk" | "single">(() => {
    try {
      const v = typeof window !== 'undefined' ? window.localStorage.getItem('cert_recipient_mode') : null;
      return v === 'single' ? 'single' : 'bulk';
    } catch { return 'bulk'; }
  });
  useEffect(() => {
    try { window.localStorage.setItem('cert_recipient_mode', recipientMode); } catch {}
  }, [recipientMode]);

  // Track per-recipient selected file object
  const [filesById, setFilesById] = useState<Record<string, File | undefined>>({});
  const [fileInputKeys, setFileInputKeys] = useState<Record<string, number>>({});

  // Initialize file names from stored URLs when students data is loaded
  const initializeFileNames = useCallback((studentsList: StudentRow[]) => {
    const initialFileNames = studentsList.reduce((acc: Record<string, string>, student) => {
      if (student.fileUrl) {
        try {
          const url = new URL(student.fileUrl);
          acc[student.id] = url.pathname.split('/').pop() || '';
        } catch (e) {
          console.error('Invalid file URL:', student.fileUrl);
        }
      }
      return acc;
    }, {});
    setFileNames(prev => ({ ...prev, ...initialFileNames }));
  }, []);

  // Save file input states to localStorage when they change
  useEffect(() => {
    if (Object.keys(fileInputKeys).length > 0) {
      localStorage.setItem('certificateFileInputs', JSON.stringify(fileInputKeys));
    }
  }, [fileInputKeys]);

  const updateFileInputState = useCallback((studentId: string) => {
    setFileInputKeys(prev => ({
      ...prev,
      [studentId]: (prev[studentId] || 0) + 1
    }));
  }, []);

  const clearFileInputState = useCallback((studentId: string) => {
    setFileInputKeys(prev => {
      const newState = { ...prev };
      delete newState[studentId];
      return newState;
    });
    setFileNames(prev => {
      const newState = { ...prev };
      delete newState[studentId];
      return newState;
    });
  }, []);

  

  // minimal toast system (placed before fetch to avoid use-before-declare)
  type Toast = { id: number; type: "success" | "error" | "info"; text: string };
  const [toasts, setToasts] = useState<Toast[]>([]);
  const toast = useCallback((text: string, type: Toast["type"] = "info") => {
    const id = Date.now() + Math.random();
    setToasts((t) => [...t, { id, type, text }]);
    setTimeout(() => setToasts((t) => t.filter((x) => x.id !== id)), 3500);
  }, []);

  const [importCohort, setImportCohort] = useState("");
  const [importHeaders, setImportHeaders] = useState<string[]>([]);
  const [importRows, setImportRows] = useState<string[][]>([]);
  const [importSelectedFile, setImportSelectedFile] = useState<File | null>(null);
  const [mapName, setMapName] = useState("");
  const [mapEmail, setMapEmail] = useState("");
  const [mapIssuedAt, setMapIssuedAt] = useState("");
  const [mapPosition, setMapPosition] = useState("");
  const [mapFileName, setMapFileName] = useState("");
  const [importing, setImporting] = useState(false);
  const [importPreviewCount, setImportPreviewCount] = useState(0);
  const [tableView, setTableView] = useState<"database" | "import">("database");
  const [importPage, setImportPage] = useState<number>(1);
  const [previewMenuIdx, setPreviewMenuIdx] = useState<number | null>(null);
  const [lastBatchId, setLastBatchId] = useState<string | null>(null);
  type ImportDbRow = { id: string; name: string; email: string; cohort: string; issued_at: string; cert_code: string; file_display_name?: string | null };
  const [importDbRows, setImportDbRows] = useState<ImportDbRow[]>([]);
  const [loadingImportDb, setLoadingImportDb] = useState(false);

  const fetchImportBatch = useCallback(async (batchId: string) => {
    setLoadingImportDb(true);
    try {
      const sb = getBrowserSupabase();
      const { data, error } = await sb
        .from("students")
        .select("id,name,email,cohort,issued_at,cert_code,file_display_name")
        .eq("import_batch_id", batchId)
        .order("created_at", { ascending: true });
      if (error) throw new Error(error.message);
      setImportDbRows((data || []) as ImportDbRow[]);
      try { console.log('[web] ImportPreview fetchImportBatch ok', { batchId, count: (data||[]).length }); } catch {}
      if ((data || []).length === 0) {
        toast(`No rows found for batch ${batchId}`, 'info');
        // auto-clear stale batch so it doesn't keep restoring on reload
        try { window.localStorage.removeItem('lastImportBatchId'); } catch {}
        setLastBatchId(null);
        // fall back to computed preview or database view
        setTableView('database');
      }
    } catch (e) {
      const msg = typeof e === 'object' && e && 'message' in e ? String((e as {message:unknown}).message) : String(e);
      toast(`Load batch failed: ${msg}`, 'error');
    } finally { setLoadingImportDb(false); }
  }, [toast]);

  useEffect(() => {
    try {
      const stored = typeof window !== 'undefined' ? window.localStorage.getItem('lastImportBatchId') : null;
      if (stored) {
        setLastBatchId(stored);
        try { console.log('[web] Restoring lastImportBatchId', { batchId: stored }); } catch {}
        toast(`Restoring import preview for batch ${stored}...`, 'info');
        void fetchImportBatch(stored);
        setTableView('import');
      }
    } catch {}
  }, [fetchImportBatch]);

  function parseCsv(text: string): { headers: string[]; rows: string[][] } {
    const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
    if (lines.length === 0) return { headers: [], rows: [] };
    const split = (l: string) => l.split(",").map(s => s.replace(/^\"|\"$/g, "").trim());
    const headers = split(lines[0]);
    const rows = lines.slice(1).map(split);
    return { headers, rows };
  }

  function mapRowsFrom(
    headers: string[],
    rows: string[][],
    mapping: { nameCol: string; emailCol: string; issuedCol: string; positionCol?: string; fileNameCol?: string }
  ): Array<{ name: string; email: string; issuedAt: string; position?: string; fileName?: string }> {
    const lower = headers.map(h => h.toLowerCase());
    const idx = (col?: string, fallback?: (s: string) => boolean) => {
      if (col) { const i = headers.indexOf(col); if (i >= 0) return i; }
      if (fallback) return lower.findIndex(fallback);
      return -1;
    };
    const idxName = idx(mapping.nameCol); // only exact 'name' or 'full name' should be passed in
    const idxEmail = idx(mapping.emailCol, s => s.includes("email"));
    const idxIssued = idx(mapping.issuedCol, s => s.includes("issued") || s.includes("date") || s.includes("time"));
    const idxPos = idx(mapping.positionCol, s => s.includes("position") || s.includes("title") || s.includes("role"));
    const idxFile = idx(mapping.fileNameCol, s => s.includes("file") || s.includes("document") || s.includes("certificate"));
    const out: Array<{ name: string; email: string; issuedAt: string; position?: string; fileName?: string }> = [];
    const toYmd = (val: string): string => {
      const s = String(val || '').trim();
      if (!s) return '';
      const d = new Date(s);
      if (!isNaN(d.getTime())) {
        const yyyy = d.getFullYear(); const mm = String(d.getMonth()+1).padStart(2,'0'); const dd = String(d.getDate()).padStart(2,'0');
        return `${yyyy}-${mm}-${dd}`;
      }
      const m1 = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})(?:\s.*)?$/);
      if (m1) {
        const M = Number(m1[1]); const D = Number(m1[2]); const Y = Number(m1[3].length === 2 ? `20${m1[3]}` : m1[3]);
        const mm = String(M).padStart(2,'0'); const dd = String(D).padStart(2,'0');
        return `${Y}-${mm}-${dd}`;
      }
      return '';
    };
    for (const r of rows) {
      let name = idxName >= 0 ? (r[idxName] || "").trim() : "";
      if (!name) {
        const fIdx = lower.findIndex(s => s.includes("first") || s.includes("given"));
        const lIdx = lower.findIndex(s => s.includes("last") || s.includes("surname") || s.includes("family"));
        const first = fIdx >= 0 ? (r[fIdx] || "").trim() : "";
        const last = lIdx >= 0 ? (r[lIdx] || "").trim() : "";
        name = [first, last].filter(Boolean).join(" ");
      }
      const email = idxEmail >= 0 ? (r[idxEmail] || "").trim() : "";
      let issuedAt = idxIssued >= 0 ? toYmd(r[idxIssued] || "") : "";
      if (!issuedAt) {
        const d = new Date(); const yyyy = d.getFullYear(); const mm = String(d.getMonth()+1).padStart(2,"0"); const dd = String(d.getDate()).padStart(2,"0");
        issuedAt = `${yyyy}-${mm}-${dd}`;
      }
      const position = idxPos >= 0 ? (r[idxPos] || "").trim() : undefined;
      const fileName = idxFile >= 0 ? (r[idxFile] || "").trim() : undefined;
      out.push({ name, email, issuedAt, position, fileName });
    }
    return out;
  }

  async function onImportFileChange(f: File | null) {
    if (!f) return;
    setImportSelectedFile(f);
    const name = f.name.toLowerCase();
    if (name.endsWith(".xlsx") || name.endsWith(".xls")) {
      const buf = await f.arrayBuffer();
      const wb = XLSX.read(buf, { type: "array" });
      const sheetName = wb.SheetNames[0];
      const ws = wb.Sheets[sheetName];
      const rowsArrayRaw: unknown[] = XLSX.utils.sheet_to_json(ws, { header: 1, raw: false });
      const rowsArray: string[][] = (rowsArrayRaw as unknown[]).map((row) => {
        const arr = Array.isArray(row) ? (row as unknown[]) : [];
        return arr.map((cell) => String(cell ?? ""));
      });
      const headers = (rowsArray[0] || []).map((h) => String(h || "").trim());
      const rows = (rowsArray.slice(1) || []).map((r) => headers.map((_, i) => String(r[i] ?? "")));
      setImportHeaders(headers);
      setImportRows(rows);
      setImportPreviewCount(Math.min(rows.length, 5));
      // auto-detect mappings
      const lower = headers.map(h => h.toLowerCase());
      const find = (pred: (s: string) => boolean) => {
        const idx = lower.findIndex(pred);
        return idx >= 0 ? headers[idx] : "";
      };
      const nameCol = find(s => /^(name|full\s*name)$/.test(s)) || "";
      const emailCol = find(s => s.includes("email")) || "";
      const issuedCol = find(s => s.includes("issued")) || find(s => s.includes("date")) || find(s => s.includes("time")) || "";
      const positionCol = find(s => s.includes("position") || s.includes("title") || s.includes("role")) || "";
      const fileNameCol = find(s => s.includes("file") || s.includes("document") || s.includes("certificate")) || "";
      setMapName(nameCol); setMapEmail(emailCol); setMapIssuedAt(issuedCol); setMapPosition(positionCol); setMapFileName(fileNameCol);
      // auto-import if cohort set
      if (importCohort.trim()) {
        try {
          const mappedAll = mapRowsFrom(headers, rows, { nameCol, emailCol, issuedCol, positionCol, fileNameCol });
          const mapped = mappedAll.filter(r => r.name && r.email && r.issuedAt).map(r => ({ name: r.name, email: r.email, issuedAt: r.issuedAt, position: r.position, fileName: r.fileName }));
          if (mapped.length === 0) { toast('No valid rows to import (missing name/email/issuedAt)', 'error'); return; }
          const genBid = (typeof window !== 'undefined' && (window.crypto as any)?.randomUUID)
            ? (window.crypto as any).randomUUID()
            : `${Date.now()}-${Math.random().toString(36).slice(2)}`;
          try { window.localStorage.setItem('lastImportBatchId', genBid); } catch {}
          setLastBatchId(genBid);
          const body = { cohort: importCohort.trim(), rows: mapped, batchId: genBid };
          try { console.log('[web] /api/certificates/import (auto XLSX) request', { cohort: body.cohort, rowsCount: mapped.length }); } catch {}
          const resp = await fetch("/api/certificates/import", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
          let json: any = null; try { json = await resp.json(); } catch {}
          try { console.log('[web] /api/certificates/import (auto XLSX) response', { status: resp.status, ok: resp.ok, summary: json?.summary, batchId: json?.batchId }); } catch {}
          if (!resp.ok) { toast(`Import failed: ${json?.error || resp.status}`, "error"); }
          else {
            const ins = json?.summary?.inserted || 0; const upd = json?.summary?.updated || 0; const sk = json?.summary?.skipped || 0;
            const bid = genBid;
            if (Array.isArray(json?.batchRows)) { setImportDbRows(json.batchRows as any); }
            else { void fetchImportBatch(bid); }
            toast(`Import saved to database — batch ${bid}. Inserted ${ins}, Updated ${upd}, Skipped ${sk}`, "success"); await fetchStudents(); setTableView("import");
          }
        } catch (e) { const msg = typeof e === 'object' && e && 'message' in e ? String((e as {message:unknown}).message) : String(e); toast(`Import error: ${msg}`, 'error'); }
      } else {
        toast("Select cohort to import", "error");
      }
      return;
    }
    const text = await f.text();
    const { headers, rows } = parseCsv(text);
    setImportHeaders(headers);
    setImportRows(rows);
    setImportPreviewCount(Math.min(rows.length, 5));
    const lower = headers.map(h => h.toLowerCase());
    const find = (pred: (s: string) => boolean) => {
      const idx = lower.findIndex(pred);
      return idx >= 0 ? headers[idx] : "";
    };
    const nameCol = find(s => /^(name|full\s*name)$/.test(s)) || "";
    const emailCol = find(s => s.includes("email")) || "";
    const issuedCol = find(s => s.includes("issued")) || find(s => s.includes("date")) || find(s => s.includes("time")) || "";
    const positionCol = find(s => s.includes("position") || s.includes("title") || s.includes("role")) || "";
    const fileNameCol = find(s => s.includes("file") || s.includes("document") || s.includes("certificate")) || "";
    setMapName(nameCol); setMapEmail(emailCol); setMapIssuedAt(issuedCol); setMapPosition(positionCol); setMapFileName(fileNameCol);
    if (importCohort.trim()) {
      try {
        const mappedAll = mapRowsFrom(headers, rows, { nameCol, emailCol, issuedCol, positionCol, fileNameCol });
        const mapped = mappedAll.filter(r => r.name && r.email && r.issuedAt).map(r => ({ name: r.name, email: r.email, issuedAt: r.issuedAt, position: r.position, fileName: r.fileName }));
        if (mapped.length === 0) { toast('No valid rows to import (missing name/email/issuedAt)', 'error'); return; }
        const genBid = (typeof window !== 'undefined' && (window.crypto as any)?.randomUUID)
          ? (window.crypto as any).randomUUID()
          : `${Date.now()}-${Math.random().toString(36).slice(2)}`;
        try { window.localStorage.setItem('lastImportBatchId', genBid); } catch {}
        setLastBatchId(genBid);
        const body = { cohort: importCohort.trim(), rows: mapped, batchId: genBid };
        try { console.log('[web] /api/certificates/import (auto CSV) request', { cohort: body.cohort, rowsCount: mapped.length }); } catch {}
        const resp = await fetch("/api/certificates/import", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
        let json: any = null; try { json = await resp.json(); } catch {}
        try { console.log('[web] /api/certificates/import (auto CSV) response', { status: resp.status, ok: resp.ok, summary: json?.summary, batchId: json?.batchId }); } catch {}
        if (!resp.ok) { toast(`Import failed: ${json?.error || resp.status}`, "error"); }
        else {
          const ins = json?.summary?.inserted || 0; const upd = json?.summary?.updated || 0; const sk = json?.summary?.skipped || 0;
          const bid = genBid;
          if (Array.isArray(json?.batchRows)) { setImportDbRows(json.batchRows as any); }
          else { void fetchImportBatch(bid); }
          toast(`Import saved to database — batch ${bid}. Inserted ${ins}, Updated ${upd}, Skipped ${sk}`, "success"); await fetchStudents(); setTableView("import");
        }
      } catch (e) { const msg = typeof e === 'object' && e && 'message' in e ? String((e as {message:unknown}).message) : String(e); toast(`Import error: ${msg}`, 'error'); }
    } else {
      toast("Select cohort to import", "error");
    }
  }

  

  function mappedIndex(name: string) {
    const idx = importHeaders.findIndex(h => h === name);
    return idx >= 0 ? idx : -1;
  }

  function buildMappedRows(): Array<{ _idx: number; name: string; email: string; issuedAt: string; position?: string; fileName?: string; firstName?: string; lastName?: string }> {
    const lower = importHeaders.map(h => h.toLowerCase());
    const idxBy = (pred: (s: string) => boolean) => lower.findIndex(pred);
    const idxName = importHeaders.indexOf(mapName);
    const idxEmail = importHeaders.indexOf(mapEmail) >= 0 ? importHeaders.indexOf(mapEmail) : idxBy(s => s.includes("email"));
    const idxIssuedAt = importHeaders.indexOf(mapIssuedAt) >= 0 ? importHeaders.indexOf(mapIssuedAt) : (idxBy(s => s.includes("issued")) >= 0 ? idxBy(s => s.includes("issued")) : (idxBy(s => s.includes("date")) >= 0 ? idxBy(s => s.includes("date")) : idxBy(s => s.includes("time"))));
    const idxPosition = mapPosition ? importHeaders.indexOf(mapPosition) : idxBy(s => s.includes("position") || s.includes("title") || s.includes("role"));
    const idxFileName = mapFileName ? importHeaders.indexOf(mapFileName) : idxBy(s => s.includes("file") || s.includes("document") || s.includes("certificate"));
    const out: Array<{ _idx: number; name: string; email: string; issuedAt: string; position?: string; fileName?: string; firstName?: string; lastName?: string }> = [];
    const toYmd = (val: string): string => {
      const s = String(val || '').trim();
      if (!s) return '';
      const d = new Date(s);
      if (!isNaN(d.getTime())) {
        const yyyy = d.getFullYear(); const mm = String(d.getMonth()+1).padStart(2,'0'); const dd = String(d.getDate()).padStart(2,'0');
        return `${yyyy}-${mm}-${dd}`;
      }
      const m1 = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})(?:\s.*)?$/);
      if (m1) {
        const M = Number(m1[1]); const D = Number(m1[2]); const Y = Number(m1[3].length === 2 ? `20${m1[3]}` : m1[3]);
        const mm = String(M).padStart(2,'0'); const dd = String(D).padStart(2,'0');
        return `${Y}-${mm}-${dd}`;
      }
      return '';
    };
    for (let i = 0; i < importRows.length; i++) {
      const r = importRows[i];
      let name = idxName >= 0 ? (r[idxName] || "").trim() : "";
      let firstName: string | undefined = undefined;
      let lastName: string | undefined = undefined;
      if (!name) {
        const fIdx = idxBy(s => s.includes("first"));
        const lIdx = idxBy(s => s.includes("last"));
        const first = fIdx >= 0 ? (r[fIdx] || "").trim() : "";
        const last = lIdx >= 0 ? (r[lIdx] || "").trim() : "";
        firstName = first || undefined;
        lastName = last || undefined;
        name = [first, last].filter(Boolean).join(" ");
      }
      const email = idxEmail >= 0 ? (r[idxEmail] || "").trim() : "";
      let issuedAt = idxIssuedAt >= 0 ? toYmd(r[idxIssuedAt] || "") : "";
      if (!issuedAt) {
        const d = new Date();
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        issuedAt = `${yyyy}-${mm}-${dd}`;
      }
      const position = idxPosition >= 0 ? (r[idxPosition] || "").trim() : undefined;
      const fileName = idxFileName >= 0 ? (r[idxFileName] || "").trim() : undefined;
      // if we had an explicit name column, try split first/last heuristically
      if (!firstName && !lastName && name) {
        const parts = name.split(/\s+/).filter(Boolean);
        if (parts.length >= 2) {
          firstName = parts[0];
          lastName = parts.slice(1).join(" ");
        } else if (parts.length === 1) {
          firstName = parts[0];
        }
      }
      out.push({ _idx: i, name, email, issuedAt, position, fileName, firstName, lastName });
    }
    return out;
  }

  const canImport = useMemo(() => {
    return importHeaders.length > 0 && importRows.length > 0 && importCohort.trim().length > 0;
  }, [importHeaders.length, importRows.length, importCohort]);

  const importMapped = useMemo(() => {
    if (importHeaders.length === 0 || importRows.length === 0) return [] as Array<{ _idx: number; name: string; email: string; issuedAt: string; position?: string; fileName?: string; cohort: string; firstName?: string; lastName?: string }>;
    const base = buildMappedRows();
    return base.map(r => ({ ...r, cohort: importCohort.trim() }));
  }, [importHeaders, importRows, importCohort, buildMappedRows]);

  const previewCodeByIdx = useMemo(() => {
    const counts: Record<string, number> = {};
    const map: Record<number, string> = {};
    for (const r of importMapped) {
      const key = `${r.cohort}|${r.name}|${r.issuedAt}`;
      counts[key] = (counts[key] || 0) + 1;
      try {
        const d = new Date(`${r.issuedAt}T00:00:00Z`);
        const code = generateCertificateCode({ companyPrefix: AURORA_PREFIX, cohort: r.cohort, fullName: r.name, issuedAt: d, seq: counts[key] });
        map[r._idx] = code;
      } catch {
        map[r._idx] = "";
      }
    }
    return map;
  }, [importMapped]);

  // Prefer DB-backed preview if we have a last batch id
  const importSource = useMemo(() => {
    if (lastBatchId && importDbRows.length > 0) return importDbRows as any[];
    return importMapped as any[];
  }, [lastBatchId, importDbRows, importMapped]);

  // Live dataset from DB
  const [studentList, setStudentList] = useState<StudentRow[]>([]);
  type SupaStudentRow = { id: string; name: string; email: string; position: string; cohort: string; issued_at: string; seq: number; status: "active" | "suspended"; file_url?: string | null };
  const fetchStudents = useCallback(async () => {
    const sb = getBrowserSupabase();
    const { data, error } = await sb
      .from("students")
      .select("id,name,email,position,cohort,issued_at,seq,status,file_url")
      .order("created_at", { ascending: false });
    if (error) {
      toast(`Load failed: ${error.message}`, "error");
      return;
    }
    const rows: StudentRow[] = (data as SupaStudentRow[] | null)?.map((d) => ({
      id: d.id,
      name: d.name,
      email: d.email,
      position: d.position,
      cohort: d.cohort,
      issuedAt: d.issued_at,
      seq: d.seq,
      status: d.status,
      fileUrl: d.file_url ?? null,
    })) ?? [];
    setStudentList(rows);
  }, [toast]);
  useEffect(() => { void fetchStudents(); }, [fetchStudents]);

  const onServerImport = useCallback(async () => {
    if (!importSelectedFile) { toast('Choose a CSV/XLSX file first', 'error'); return; }
    if (!importCohort.trim()) { toast('Set Cohort for this import', 'error'); return; }
    try {
      setImporting(true);
      const fd = new FormData();
      fd.append('cohort', importCohort.trim());
      fd.append('file', importSelectedFile);
      if (mapName) fd.append('mapName', mapName);
      if (mapEmail) fd.append('mapEmail', mapEmail);
      if (mapIssuedAt) fd.append('mapIssuedAt', mapIssuedAt);
      if (mapPosition) fd.append('mapPosition', mapPosition);
      if (mapFileName) fd.append('mapFileName', mapFileName);
      const resp = await fetch('/api/certificates/import-file', { method: 'POST', body: fd });
      const json = await resp.json();
      if (!resp.ok) { toast(json?.error || `Import failed (${resp.status})`, 'error'); return; }
      const bid: string | null = json?.batchId ? String(json.batchId) : null;
      const ins = json?.summary?.inserted || 0; const upd = json?.summary?.updated || 0; const sk = json?.summary?.skipped || 0;
      if (bid) {
        try { window.localStorage.setItem('lastImportBatchId', bid); } catch {}
        setLastBatchId(bid);
        toast(`Server import complete — +${ins} inserted, +${upd} updated, +${sk} skipped`, 'success');
        await fetchStudents();
        setTableView('import');
        void fetchImportBatch(bid);
      } else {
        toast(`Server import complete — +${ins} inserted, +${upd} updated, +${sk} skipped`, 'success');
        await fetchStudents();
      }
    } catch (e) {
      const msg = typeof e === 'object' && e && 'message' in e ? String((e as {message:unknown}).message) : String(e);
      toast(`Server import error: ${msg}`, 'error');
    } finally {
      setImporting(false);
    }
  }, [importSelectedFile, importCohort, mapName, mapEmail, mapIssuedAt, mapPosition, mapFileName, fetchStudents, fetchImportBatch, toast, setLastBatchId, setTableView]);

  // Bulk filters
  const [filterCohorts, setFilterCohorts] = useState<string[]>([]);
  const [filterYears, setFilterYears] = useState<string[]>([]);
  const [filterStatuses, setFilterStatuses] = useState<Array<"active" | "suspended">>([]);
  const [filterSearch, setFilterSearch] = useState<string>("");

  const availableCohorts = useMemo(() => Array.from(new Set(studentList.map(s => s.cohort))).sort(), [studentList]);
  const availableYears = useMemo(() => Array.from(new Set(studentList.map(s => s.issuedAt.slice(0,4)))).sort(), [studentList]);

  const filteredStudents = useMemo(() => {
    return studentList.filter((s) => {
      const byCohort = filterCohorts.length === 0 || filterCohorts.includes(s.cohort);
      const year = s.issuedAt.slice(0,4);
      const byYear = filterYears.length === 0 || filterYears.includes(year);
      const byStatus = filterStatuses.length === 0 || filterStatuses.includes(s.status);
      const q = filterSearch.trim().toLowerCase();
      const bySearch = q.length === 0
        || s.name.toLowerCase().includes(q)
        || s.email.toLowerCase().includes(q)
        || s.cohort.toLowerCase().includes(q)
        || (s.status === "active" && "active".includes(q))
        || (s.status === "suspended" && "suspended".includes(q));
      return byCohort && byYear && byStatus && bySearch;
    });
  }, [studentList, filterCohorts, filterYears, filterStatuses, filterSearch]);

  // Single search
  const [singleQuery, setSingleQuery] = useState<string>("");
  const [selectedSingleId, setSelectedSingleId] = useState<string | null>(() => {
    try {
      const v = typeof window !== 'undefined' ? window.localStorage.getItem('cert_selected_single_id') : null;
      return v || null;
    } catch { return null; }
  });
  useEffect(() => {
    try {
      if (selectedSingleId) window.localStorage.setItem('cert_selected_single_id', selectedSingleId);
      else window.localStorage.removeItem('cert_selected_single_id');
    } catch {}
  }, [selectedSingleId]);
  const singleSuggestions = useMemo(() => {
    const q = singleQuery.trim().toLowerCase();
    if (!q) return [] as StudentRow[];
    return studentList.filter(s => s.name.toLowerCase().includes(q) || s.email.toLowerCase().includes(q) || s.cohort.toLowerCase().includes(q)).slice(0,5);
  }, [studentList, singleQuery]);
  const selectedSingle = useMemo(() => studentList.find(s => s.id === selectedSingleId) || null, [studentList, selectedSingleId]);

  // Pagination for table
  const PAGE_SIZE = 10;
  const [page, setPage] = useState<number>(1);
  // Reset page only when mode or filters change (not when filtered array identity changes)
  useEffect(() => {
    setPage(1);
  }, [recipientMode, filterCohorts, filterYears, filterStatuses, filterSearch, selectedSingleId]);
  // Clamp page to valid range when list size changes
  useEffect(() => {
    const currentLen = recipientMode === "bulk"
      ? filteredStudents.length
      : (selectedSingleId ? 1 : 0);
    const totalPagesNext = Math.max(1, Math.ceil(currentLen / PAGE_SIZE));
    if (page > totalPagesNext) setPage(totalPagesNext);
  }, [recipientMode, filteredStudents.length, selectedSingleId, PAGE_SIZE, page]);

  // Import preview pagination derived after PAGE_SIZE
  const importTotal = importSource.length;
  const importTotalPages = Math.max(1, Math.ceil(importTotal / PAGE_SIZE));
  const importPageStart = (importPage - 1) * PAGE_SIZE;
  const importPageItems = useMemo(() => importSource.slice(importPageStart, importPageStart + PAGE_SIZE), [importSource, importPageStart, PAGE_SIZE]);

  // Row editing state
  const [editingId, setEditingId] = useState<string | null>(null);
  const [editDraft, setEditDraft] = useState<StudentInput | null>(null);
  const startEdit = (id: string) => {
    const s = studentList.find((x) => x.id === id);
    if (!s) return;
    setEditingId(id);
    setEditDraft({ name: s.name, email: s.email, position: s.position, cohort: s.cohort, issuedAt: s.issuedAt });
  };

  // Row actions dropdown state
  const [openMenuId, setOpenMenuId] = useState<string | null>(null);
  const toggleMenu = (id: string) => {
    setOpenMenuId((cur) => (cur === id ? null : id));
  };

  // Close dropdown on outside click and on Escape
  useEffect(() => {
    function onDocClick(e: MouseEvent) {
      if (!openMenuId) return;
      const t = e.target as HTMLElement | null;
      if (!t) return;
      const inActions = t.closest('.row-actions') || t.closest('#actions-popover');
      if (!inActions) setOpenMenuId(null);
    }
    function onKey(e: KeyboardEvent) {
      if (e.key === 'Escape') setOpenMenuId(null);
    }
    document.addEventListener('mousedown', onDocClick);
    document.addEventListener('keydown', onKey);
    return () => {
      document.removeEventListener('mousedown', onDocClick);
      document.removeEventListener('keydown', onKey);
    };
  }, [openMenuId]);

  // Row for the open menu (if any)
  const openMenuRow = useMemo(() => studentList.find((s) => s.id === openMenuId) || null, [studentList, openMenuId]);


  async function copyCode(s: StudentRow) {
    try {
      const { code } = renderBodyFor(s);
      await navigator.clipboard.writeText(code);
      toast("Code copied", "success");
    } catch (e) {
      const msg = typeof e === "object" && e && "message" in e ? String((e as { message: unknown }).message) : String(e);
      toast(`Copy failed: ${msg}`, "error");
    }
  }
  const saveEdit = async () => {
    if (!editingId || !editDraft) return;
    const current = studentList.find((s) => s.id === editingId);
    if (!current) return;
    const merged: StudentRow = { ...current, ...editDraft } as StudentRow;
    await saveRow(merged);
    setEditingId(null);
    setEditDraft(null);
  };
  const cancelEdit = () => {
    setEditingId(null);
    setEditDraft(null);
  };
  const toggleSuspend = (id: string) => {
    setStudentList((list) => list.map((s) => (s.id === id ? { ...s, status: s.status === "suspended" ? "active" : "suspended" } : s)));
    // Demo notification
    const s = studentList.find((x) => x.id === id);
    if (s) {
      const action = s.status === "suspended" ? "re-activated" : "suspended";
      alert(`A notification email would be sent to ${s.email}: account ${action}.`);
    }
  };
  const deleteRow = async (id: string) => {
    if (!confirm("Delete this student?")) return;
    try {
      const resp = await fetch("/api/certificates/delete", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ id }),
      });
      const json = await resp.json();
      if (!resp.ok) {
        toast(`Delete failed: ${json?.error || resp.status}`, "error");
        return;
      }
      toast("Deleted", "success");
      void fetchStudents();
    } catch (e) {
      const msg = typeof e === "object" && e && "message" in e ? String((e as { message: unknown }).message) : String(e);
      toast(`Error: ${msg}`, "error");
    }
  };

  // Preview modal state
  const [previewOpen, setPreviewOpen] = useState(false);
  const [previewTo, setPreviewTo] = useState<string>("");
  const [previewSubject, setPreviewSubject] = useState<string>("");
  const [previewBody, setPreviewBody] = useState<string>("");
  const openPreview = (s: StudentRow) => {
    const sCode = generateCertificateCode({ companyPrefix: AURORA_PREFIX, cohort: s.cohort, fullName: s.name, issuedAt: new Date(`${s.issuedAt}T00:00:00Z`), seq: s.seq });
    const rendered = body
      .replace(/\{\{name\}\}/g, s.name)
      .replace(/\{\{position\}\}/g, s.position)
      .replace(/\{\{cohort\}\}/g, s.cohort)
      .replace(/\{\{cert_code\}\}/g, sCode)
      .replace(/\{\{verify_url\}\}/g, `https://aurora.example/verify/${encodeURIComponent(sCode)}`);
    setPreviewTo(s.email);
    setPreviewSubject(subject);
    setPreviewBody(rendered);
    setPreviewOpen(true);
  };

  // Current selection list based on mode
  const selectedList: StudentRow[] = useMemo(() => {
    return recipientMode === "bulk" ? filteredStudents : selectedSingle ? [selectedSingle] : [];
  }, [recipientMode, filteredStudents, selectedSingle]);

  const pageStart = (page - 1) * PAGE_SIZE;
  const pageItems = useMemo(() => selectedList.slice(pageStart, pageStart + PAGE_SIZE), [selectedList, pageStart]);
  const totalPages = Math.max(1, Math.ceil(selectedList.length / PAGE_SIZE));

  const [sending, setSending] = useState(false);
  const [lastResult, setLastResult] = useState<string>("");
  const [statusesById, setStatusesById] = useState<Record<string, "pending" | "sent" | "failed">>({});
  const [errorsById, setErrorsById] = useState<Record<string, string>>({});
  const [requireAttachment, setRequireAttachment] = useState<boolean>(() => {
    try {
      const v = typeof window !== 'undefined' ? window.localStorage.getItem('cert_require_attachment') : null;
      if (v === '0') return false;
      if (v === '1') return true;
      return true;
    } catch { return true; }
  });
  useEffect(() => {
    try { window.localStorage.setItem('cert_require_attachment', requireAttachment ? '1' : '0'); } catch {}
  }, [requireAttachment]);
  const [dragOverId, setDragOverId] = useState<string | null>(null);
  const selectionCount = selectedList.length;
  const missingAttachments = useMemo(() => selectedList.filter(s => !filesById[s.id] && !s.fileUrl), [selectedList, filesById]);
  const hasSubject = subject.trim().length > 0;
  const hasBody = body.trim().length > 0;
  const dailyCap = 100;
  const estimatedDays = Math.max(1, Math.ceil(selectionCount / dailyCap));
  const canSendEmails = useMemo(() => {
    if (sending) return false;
    if (!hasSubject || !hasBody) return false;
    if (recipientMode === "bulk" && selectionCount === 0) return false;
    if (recipientMode === "single" && selectedList.length !== 1) return false;
    if (requireAttachment && selectedList.some(s => !filesById[s.id] && !s.fileUrl)) return false;
    return true;
  }, [sending, hasSubject, hasBody, recipientMode, selectionCount, selectedList, requireAttachment, filesById]);

  // Print/PDF via hidden iframe (avoids popup blockers)
  const tableRef = useRef<HTMLDivElement | null>(null);
  function printHtml(html: string) {
    const iframe = document.createElement("iframe");
    iframe.style.position = "fixed";
    iframe.style.left = "-9999px";
    iframe.style.top = "0";
    iframe.width = "0";
    iframe.height = "0";
    document.body.appendChild(iframe);
    const doc = iframe.contentWindow?.document;
    if (!doc) { document.body.removeChild(iframe); return; }
    doc.open();
    doc.write(`<!doctype html><html><head><meta charset=\"utf-8\"/><title>Certificates</title>
      <style>
        body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;background:#fff;color:#111;padding:16px}
        table{width:100%;border-collapse:collapse;font-size:12px}
        th,td{border:1px solid #ddd;padding:6px}
        thead th{background:#f3f4f6;position:sticky;top:0}
        .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
      </style></head><body>${html}</body></html>`);
    doc.close();
    const w = iframe.contentWindow;
    setTimeout(() => {
      try { w?.focus(); w?.print(); } catch {}
      setTimeout(() => { document.body.removeChild(iframe); }, 300);
    }, 50);
  }
  function downloadPdf() {
    try {
      const html = tableRef.current ? tableRef.current.innerHTML : "";
      printHtml(html);
    } catch {}
  }
  function downloadPdfAll() {
    try {
      const rows = selectedList;
      const headers = ["#","Name","Email","Position","Cohort","Code","Issued","Status"];
      const bodyRows = rows.map((s, i) => {
        let code = "";
        try { code = generateCertificateCode({ companyPrefix: AURORA_PREFIX, cohort: s.cohort, fullName: s.name, issuedAt: new Date(`${s.issuedAt}T00:00:00Z`), seq: s.seq }); } catch {}
        return [String(i+1), s.name, s.email, s.position, s.cohort, code, s.issuedAt, s.status];
      });
      const tableHtml = `
        <h1 style=\"margin:0 0 12px 0;font-size:16px\">Certificates Export (${rows.length} rows)</h1>
        <table>
          <thead><tr>${headers.map(h=>`<th>${h}</th>`).join("")}</tr></thead>
          <tbody>
            ${bodyRows.map(r=>`<tr>${r.map(c=>`<td>${String(c).replace(/&/g,'&amp;').replace(/</g,'&lt;')}</td>`).join("")}</tr>`).join("")}
          </tbody>
        </table>`;
      printHtml(tableHtml);
    } catch (e) {
      const msg = typeof e === 'object' && e && 'message' in e ? String((e as {message:unknown}).message) : String(e);
      toast(`Export failed: ${msg}`, "error");
    }
  }

  function toHtml(src: string): string {
    const esc = src.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    const blocks = esc.split(/\n\s*\n/);
    return blocks.map((b) => `<p>${b.replace(/\n/g, '<br/>')}</p>`).join("\n");
  }

  function renderBodyFor(s: StudentRow): { rendered: string; code: string } {
    const sCode = generateCertificateCode({ companyPrefix: AURORA_PREFIX, cohort: s.cohort, fullName: s.name, issuedAt: new Date(`${s.issuedAt}T00:00:00Z`), seq: s.seq });
    const rendered = body
      .replace(/\{\{name\}\}/g, s.name)
      .replace(/\{\{position\}\}/g, s.position)
      .replace(/\{\{cohort\}\}/g, s.cohort)
      .replace(/\{\{cert_code\}\}/g, sCode)
      .replace(/\{\{verify_url\}\}/g, `https://aurora.example/verify/${encodeURIComponent(sCode)}`);
    return { rendered, code: sCode };
  }

  async function fileToBase64(file: File): Promise<string> {
    const buf = await file.arrayBuffer();
    const bytes = new Uint8Array(buf);
    let binary = "";
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  async function urlToBase64(url: string): Promise<string> {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Fetch failed: ${resp.status}`);
    const blob = await resp.blob();
    const buf = await blob.arrayBuffer();
    const bytes = new Uint8Array(buf);
    let binary = "";
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  type SendResult = { email: string; ok: boolean; id?: string; error?: string };

  async function saveRow(s: StudentRow) {
    // Client-side duplicate checks
    const existsSameKey = studentList.find((x) => x.id !== s.id && x.email === s.email && x.cohort === s.cohort && x.issuedAt === s.issuedAt);
    if (existsSameKey) {
      toast("Duplicate (email + cohort + date) exists. Edit that row instead.", "error");
      return;
    }
    try {
      try { console.log("[web] /api/certificates/save request:", { name: s.name, email: s.email, position: s.position, cohort: s.cohort, issuedAt: s.issuedAt, seq: s.seq, hasId: !!s.id }); } catch {}
      const resp = await fetch("/api/certificates/save", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          id: s.id && s.id.length === 36 ? s.id : undefined,
          name: s.name,
          email: s.email,
          position: s.position,
          cohort: s.cohort,
          issuedAt: s.issuedAt,
          seq: s.seq,
          status: s.status,
        }),
      });
      let json: any = null;
      try { json = await resp.json(); } catch (e) { try { console.error("[web] /api/certificates/save non-JSON response", e); } catch {} }
      try { console.log("[web] /api/certificates/save response:", { status: resp.status, ok: resp.ok, json }); } catch {}
      if (!resp.ok) {
        toast(`Save failed: ${json?.error || resp.status}`, "error");
        return;
      }
      toast("Saved", "success");
      void fetchStudents();
    } catch (e) {
      const msg = typeof e === "object" && e && "message" in e ? String((e as { message: unknown }).message) : String(e);
      toast(`Error: ${msg}`, "error");
    }
  }

  // removed per user request: Add All

  async function sendRecipients(recipients: StudentRow[]) {
    setSending(true);
    setLastResult("");
    // initialize pending status for those being sent now
    setStatusesById((prev) => {
      const copy = { ...prev };
      for (const s of recipients) copy[s.id] = "pending";
      return copy;
    });
    try {
      const items = await Promise.all(
        recipients.map(async (s) => {
          const { rendered, code } = renderBodyFor(s);
          const f = filesById[s.id];
          let attachments: { name: string; contentBase64: string }[] = [];
          if (f) {
            attachments = [{ name: f.name, contentBase64: await fileToBase64(f) }];
          } else if (s.fileUrl) {
            try {
              const base64 = await urlToBase64(s.fileUrl);
              const guessedName = decodeURIComponent(s.fileUrl.split('/').pop() || 'certificate.pdf');
              attachments = [{ name: guessedName, contentBase64: base64 }];
            } catch {}
          }
          return {
            email: s.email,
            name: s.name,
            subject,
            body: toHtml(rendered),
            attachments,
            meta: { cert_code: code, student_id: s.id },
          };
        })
      );

      const resp = await fetch("/api/email/send", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ recipients: items }),
      });
      let json: { results?: SendResult[]; error?: string } | null = null;
      try { json = (await resp.json()) as { results?: SendResult[]; error?: string }; } catch (e) { try { console.error("[web] /api/email/send non-JSON response", e); } catch {} }
      try { console.log("[web] /api/email/send response:", { status: resp.status, ok: resp.ok, json }); } catch {}
      if (!resp.ok) {
        toast(`Send failed: ${json?.error || resp.status}`, "error");
      } else {
        const results = Array.isArray(json?.results) ? json!.results : [];
        // map results back to ids by email
        setStatusesById((prev) => {
          const copy = { ...prev };
          for (const s of recipients) {
            const r = results.find((x) => x.email === s.email);
            if (r) copy[s.id] = r.ok ? "sent" : "failed";
          }
          return copy;
        });
        setErrorsById((prev) => {
          const copy = { ...prev };
          for (const s of recipients) {
            const r = results.find((x) => x.email === s.email);
            if (r && !r.ok && r.error) copy[s.id] = r.error;
          }
          return copy;
        });
        const ok = results.filter((r) => r.ok).length;
        const fail = results.length - ok;
        setLastResult(`Sent: ${ok}, Failed: ${fail}`);
        toast(`Send complete. ${ok} sent, ${fail} failed.`, "success");
      }
    } catch (e: unknown) {
      const msg = typeof e === "object" && e && "message" in e ? String((e as { message: unknown }).message) : String(e);
      toast(`Error: ${msg}`, "error");
    } finally {
      setSending(false);
    }
  }

  const code = useMemo(() => {
    try {
      const d = new Date(`${row.issuedAt}T00:00:00Z`);
      return generateCertificateCode({
        companyPrefix: AURORA_PREFIX,
        cohort: row.cohort,
        fullName: row.name,
        issuedAt: d,
        seq,
      });
    } catch {
      return "";
    }
  }, [row, seq]);

  return (
    <div className="min-h-screen bg-gray-900 text-white p-6">
      <header className="mb-6 flex items-center justify-between">
        <h1 className="text-2xl font-bold">Certificates</h1>
        <div className="inline-flex rounded border border-gray-700 overflow-hidden">
          <button
            className={`px-3 py-1.5 text-sm ${mode === "manual" ? "bg-[#CCFF00] text-black" : "bg-gray-800"}`}
            onClick={() => setMode("manual")}
          >Manual</button>
          <button
            className={`px-3 py-1.5 text-sm ${mode === "auto" ? "bg-[#CCFF00] text-black" : "bg-gray-800"}`}
            onClick={() => setMode("auto")}
          >Auto</button>
        </div>
      </header>

      <section className="bg-gray-800 p-4 rounded-lg border border-gray-700">
        <h2 className="text-lg font-semibold mb-3">Generate code</h2>
        <p className="text-gray-300 text-sm mb-4">Format: AURORA-&lt;COHORT&gt;-NAM3-YYMM-SEQ-CHK</p>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
          <div>
            <label className="block text-sm mb-1">Full Name</label>
            <input
              className="w-full bg-gray-700 rounded px-3 py-2"
              value={row.name}
              onChange={(e) => setRow((r) => ({ ...r, name: e.target.value }))}
              placeholder="Student full name"
            />
          </div>
          <div>
            <label className="block text-sm mb-1">Email</label>
            <input
              className="w-full bg-gray-700 rounded px-3 py-2"
              value={row.email}
              onChange={(e) => setRow((r) => ({ ...r, email: e.target.value }))}
              placeholder="student@email.com"
            />
          </div>
          <div>
            <label className="block text-sm mb-1">Position/Title</label>
            <input
              className="w-full bg-gray-700 rounded px-3 py-2"
              value={row.position}
              onChange={(e) => setRow((r) => ({ ...r, position: e.target.value }))}
              placeholder="e.g., Robotics Engineer"
            />
          </div>
          <div>
            <label className="block text-sm mb-1">Cohort</label>
            <input
              className="w-full bg-gray-700 rounded px-3 py-2"
              value={row.cohort}
              onChange={(e) => setRow((r) => ({ ...r, cohort: e.target.value.toUpperCase() }))}
              placeholder="CORE2"
            />
          </div>
          <div>
            <label className="block text-sm mb-1">Issued At</label>
            <input
              type="date"
              className="w-full bg-gray-700 rounded px-3 py-2"
              value={row.issuedAt}
              onChange={(e) => setRow((r) => ({ ...r, issuedAt: e.target.value }))}
            />
          </div>
        </div>
        <div className="mt-4 p-3 bg-gray-900/50 rounded border border-gray-700">
          <div className="text-sm text-gray-400 mb-1">Generated Code</div>
          <div className="font-mono select-all break-all">{code || "—"}</div>
        </div>
        <div className="mt-3 flex gap-2">
          <button
            className="px-3 py-2 bg-[#CCFF00] text-black rounded text-sm"
            onClick={() => void saveRow({
              // no id here so API creates a new row
              id: "", // ignored by API due to length check
              name: row.name,
              email: row.email,
              position: row.position,
              cohort: row.cohort,
              issuedAt: row.issuedAt,
              seq,
              status: "active",
            } as StudentRow)}
            title="Add this certificate row to the database"
          >Add</button>
          <span className="text-xs text-gray-400 self-center">Saves to database and appears in the table below.</span>
        </div>
        <p className="text-xs text-gray-400 mt-2">
          Manual mode: paste this code into your certificate design, export PDF/PNG, and upload.
          Auto mode: the system will place this code on your template automatically (when template is configured).
        </p>
      </section>

      <section className="mt-6 bg-gray-800 p-4 rounded-lg border border-gray-700">
        <h2 className="text-lg font-semibold mb-3">Import Students (CSV)</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
          <div>
            <label className="block text-sm mb-1">Cohort for this import</label>
            <input className="w-full bg-gray-700 rounded px-3 py-2" value={importCohort} onChange={(e) => setImportCohort(e.target.value)} placeholder="CORE2" />
          </div>
          <div>
            <label className="block text-sm mb-1">CSV/XLSX file</label>
            <input type="file" accept=".csv,text/csv,.xlsx,.xls,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel" className="w-full bg-gray-700 rounded px-3 py-2" onChange={(e) => onImportFileChange(e.target.files?.[0] || null)} />
          </div>
        </div>
        {importHeaders.length > 0 && (
          <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">
            <div>
              <label className="block text-sm mb-1">Name column</label>
              <select className="w-full bg-gray-700 rounded px-3 py-2" value={mapName} onChange={(e)=>setMapName(e.target.value)}>
                <option value="">Select</option>
                {importHeaders.map(h => <option key={h} value={h}>{h}</option>)}
              </select>
            </div>
            <div>
              <label className="block text-sm mb-1">Email column</label>
              <select className="w-full bg-gray-700 rounded px-3 py-2" value={mapEmail} onChange={(e)=>setMapEmail(e.target.value)}>
                <option value="">Select</option>
                {importHeaders.map(h => <option key={h} value={h}>{h}</option>)}
              </select>
            </div>
            <div>
              <label className="block text-sm mb-1">Issued At column</label>
              <select className="w-full bg-gray-700 rounded px-3 py-2" value={mapIssuedAt} onChange={(e)=>setMapIssuedAt(e.target.value)}>
                <option value="">Select</option>
                {importHeaders.map(h => <option key={h} value={h}>{h}</option>)}
              </select>
            </div>
            <div>
              <label className="block text-sm mb-1">Position column (optional)</label>
              <select className="w-full bg-gray-700 rounded px-3 py-2" value={mapPosition} onChange={(e)=>setMapPosition(e.target.value)}>
                <option value="">None</option>
                {importHeaders.map(h => <option key={h} value={h}>{h}</option>)}
              </select>
            </div>
            <div>
              <label className="block text-sm mb-1">File name column (optional)</label>
              <select className="w-full bg-gray-700 rounded px-3 py-2" value={mapFileName} onChange={(e)=>setMapFileName(e.target.value)}>
                <option value="">None</option>
                {importHeaders.map(h => <option key={h} value={h}>{h}</option>)}
              </select>
            </div>
          </div>
        )}
        {importHeaders.length > 0 && (
          <div className="mt-4">
            <button
              className={`px-3 py-2 rounded text-sm ${canImport && !importing ? "bg-[#CCFF00] text-black" : "bg-gray-700 text-gray-400 cursor-not-allowed"}`}
              disabled={!canImport || importing}
              onClick={async ()=>{
                try {
                  setImporting(true);
                  const mappedFull = buildMappedRows();
                  const clean = mappedFull.filter(r => r.name && r.email && r.issuedAt).map(r => ({ name: r.name, email: r.email, issuedAt: r.issuedAt, position: r.position, fileName: r.fileName }));
                  if (clean.length === 0) { toast('No valid rows to import (missing name/email/issuedAt)', 'error'); setImporting(false); return; }
                  const chunks = chunkArray(clean, 100);
                  const genBid = (typeof window !== 'undefined' && (window.crypto as any)?.randomUUID)
                    ? (window.crypto as any).randomUUID()
                    : `${Date.now()}-${Math.random().toString(36).slice(2)}`;
                  try { window.localStorage.setItem('lastImportBatchId', genBid); } catch {}
                  setLastBatchId(genBid);
                  let totalIns = 0, totalUpd = 0, totalSk = 0; let lastBid: string | null = null; let lastJson: any = null;
                  for (let i = 0; i < chunks.length; i++) {
                    const body = { cohort: importCohort.trim(), rows: chunks[i], batchId: genBid };
                    try { console.log("[web] /api/certificates/import (manual chunk)", { part: i+1, of: chunks.length, size: chunks[i].length, sample: chunks[i].slice(0,2) }); } catch {}
                    const resp = await fetch("/api/certificates/import", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
                    let json: any = null; try { json = await resp.json(); lastJson = json; } catch {}
                    if (!resp.ok) { toast(`Import part ${i+1}/${chunks.length} failed: ${json?.error || resp.status}`, "error"); setImporting(false); return; }
                    const ins = json?.summary?.inserted || 0; const upd = json?.summary?.updated || 0; const sk = json?.summary?.skipped || 0;
                    totalIns += ins; totalUpd += upd; totalSk += sk;
                    lastBid = json?.batchId ? String(json.batchId) : lastBid;
                    toast(`Imported part ${i+1}/${chunks.length}: +${ins} inserted, +${upd} updated, +${sk} skipped`, 'info');
                  }
                  const finalBid = genBid;
                  if (Array.isArray(lastJson?.batchRows)) { setImportDbRows(lastJson.batchRows as any); }
                  else { void fetchImportBatch(finalBid); }
                  toast(`Import complete — Inserted ${totalIns}, Updated ${totalUpd}, Skipped ${totalSk}`, "success");
                  // Keep preview so user can review full file after import
                  setTableView("import");
                  void fetchStudents();
                } finally { setImporting(false); }
              }}
            >{importing ? "Importing..." : "Import"}</button>
            <button
              className="ml-2 px-3 py-2 rounded text-sm bg-blue-600 hover:bg-blue-500 disabled:bg-gray-700 disabled:text-gray-400"
              disabled={importing || !importSelectedFile || !importCohort.trim()}
              title={!importSelectedFile ? 'Choose a CSV/XLSX file first' : (!importCohort.trim() ? 'Set Cohort for this import' : 'Run import on server')}
              onClick={() => { void onServerImport(); }}
            >{importing ? 'Importing...' : 'Server Import'}</button>
            {importRows.length > 0 && (
              <div className="mt-3 text-xs text-gray-400">Previewing first {importPreviewCount} rows</div>
            )}
            {importRows.length > 0 && (
              <div className="mt-2 overflow-x-auto">
                <table className="w-full text-sm">
                  <thead>
                    <tr>
                      {importHeaders.map(h => <th key={h} className="border border-gray-700 px-2 py-1 text-left">{h}</th>)}
                    </tr>
                  </thead>
                  <tbody>
                    {importRows.slice(0, importPreviewCount).map((r,i) => (
                      <tr key={i}>
                        {importHeaders.map((_,j) => <td key={j} className="border border-gray-800 px-2 py-1">{r[j]}</td>)}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        )}
      </section>

      {/* Compose section for bulk/single send */}
      <section className="mt-6 bg-gray-800 p-4 rounded-lg border border-gray-700">
        <h2 className="text-lg font-semibold mb-3">Compose Email</h2>
        <div className="mb-3 flex items-center gap-3">
          <div className="text-sm text-gray-300">Recipient Mode:</div>
          <div className="inline-flex rounded border border-gray-700 overflow-hidden">
            <button className={`px-3 py-1.5 text-sm ${recipientMode === "bulk" ? "bg-[#CCFF00] text-black" : "bg-gray-900"}`} onClick={() => setRecipientMode("bulk")}>Bulk</button>
            <button className={`px-3 py-1.5 text-sm ${recipientMode === "single" ? "bg-[#CCFF00] text-black" : "bg-gray-900"}`} onClick={() => setRecipientMode("single")}>Single</button>
          </div>
          {recipientMode === "bulk" && <div className="ml-auto text-sm text-gray-400">Matched: {filteredStudents.length}</div>}
          {recipientMode === "single" && <div className="ml-auto text-sm text-gray-400">{selectedSingle ? selectedSingle.email : "No recipient selected"}</div>}
          <button
            className={`ml-2 px-3 py-1.5 rounded text-sm ${recipientMode === "bulk" && canSendEmails ? "bg-[#CCFF00] text-black" : "bg-gray-700 text-gray-400 cursor-not-allowed"}`}
            onClick={() => { if (recipientMode === "bulk" && canSendEmails) void sendRecipients(selectedList); }}
            disabled={recipientMode !== "bulk" || !canSendEmails || sending}
            title="Send to all currently matched recipients"
          >
            {sending ? "Sending..." : "Send All (Bulk)"}
          </button>
        </div>

        {recipientMode === "bulk" && (
          <div className="mb-4 grid grid-cols-1 md:grid-cols-3 gap-3">
            <div>
              <label className="block text-sm mb-1">Cohort</label>
              <div className="flex flex-wrap gap-2 bg-gray-700 rounded p-2">
                {availableCohorts.map((c) => {
                  const checked = filterCohorts.includes(c);
                  return (
                    <label key={c} className="flex items-center gap-1 text-sm">
                      <input type="checkbox" className="accent-[#CCFF00]" checked={checked} onChange={(e) => setFilterCohorts(prev => e.target.checked ? [...prev, c] : prev.filter(x => x !== c))} />
                      <span>{c}</span>
                    </label>
                  );
                })}
              </div>
            </div>
            <div>
              <label className="block text-sm mb-1">Year</label>
              <div className="flex flex-wrap gap-2 bg-gray-700 rounded p-2">
                {availableYears.map((y) => {
                  const checked = filterYears.includes(y);
                  return (
                    <label key={y} className="flex items-center gap-1 text-sm">
                      <input type="checkbox" className="accent-[#CCFF00]" checked={checked} onChange={(e) => setFilterYears(prev => e.target.checked ? [...prev, y] : prev.filter(x => x !== y))} />
                      <span>{y}</span>
                    </label>
                  );
                })}
              </div>
            </div>
            <div>
              <label className="block text-sm mb-1">Search</label>
              <input className="w-full bg-gray-700 rounded px-3 py-2" value={filterSearch} onChange={(e) => setFilterSearch(e.target.value)} placeholder="Search name, email, cohort" />
            </div>
            <div className="md:col-span-3">
              <label className="block text-sm mb-1">Status</label>
              <div className="flex flex-wrap gap-2 bg-gray-700 rounded p-2">
                {(["active", "suspended"] as Array<"active" | "suspended">).map((st) => {
                  const checked = filterStatuses.includes(st);
                  return (
                    <label key={st} className="flex items-center gap-1 text-sm">
                      <input
                        type="checkbox"
                        className="accent-[#CCFF00]"
                        checked={checked}
                        onChange={(e) =>
                          setFilterStatuses((prev) =>
                            e.target.checked ? [...prev, st] : prev.filter((x) => x !== st)
                          )
                        }
                      />
                      <span className="capitalize">{st}</span>
                    </label>
                  );
                })}
              </div>
            </div>
          </div>
        )}

        {recipientMode === "single" && (
          <div className="mb-4">
            <label className="block text-sm mb-1">Find Recipient</label>
            <input className="w-full bg-gray-700 rounded px-3 py-2" value={singleQuery} onChange={(e) => setSingleQuery(e.target.value)} placeholder="Type name, email, cohort..." />
            {singleQuery && singleSuggestions.length > 0 && (
              <div className="mt-2 bg-gray-900 border border-gray-700 rounded divide-y divide-gray-800">
                {singleSuggestions.map((s) => (
                  <button key={s.id} className="w-full text-left px-3 py-2 hover:bg-gray-800" onClick={() => { setSelectedSingleId(s.id); setSingleQuery(""); }}>
                    <div className="text-sm">{s.name} <span className="text-gray-400">({s.email})</span></div>
                    <div className="text-xs text-gray-400">Cohort {s.cohort} • Issued {s.issuedAt}</div>
                  </button>
                ))}
              </div>
            )}
          </div>
        )}
        {/* Preflight status */}
        <div className="mb-3 text-xs text-gray-300 bg-gray-900/60 border border-gray-700 rounded p-3">
          <div className="flex flex-wrap gap-3 items-center">
            <div><span className="text-gray-400">Selected:</span> {selectionCount}</div>
            <div><span className="text-gray-400">Missing attachments:</span> {missingAttachments.length}</div>
            <div><span className="text-gray-400">Throttle est.:</span> {selectionCount} emails ≈ {estimatedDays} day{estimatedDays === 1 ? "" : "s"} at {dailyCap}/day</div>
            {sending && <div className="text-yellow-400">Sending...</div>}
            {lastResult && <div className="text-green-400">{lastResult}</div>}
            {!hasSubject && <div className="text-red-400">Subject required</div>}
            {!hasBody && <div className="text-red-400">Body required</div>}
            {requireAttachment && missingAttachments.length > 0 && <div className="text-yellow-400">Attach files for all selected rows</div>}
            <label className="ml-auto inline-flex items-center gap-2 text-xs">
              <input type="checkbox" className="accent-[#CCFF00]" checked={requireAttachment} onChange={(e)=>setRequireAttachment(e.target.checked)} />
              <span>Require attachment to send</span>
            </label>
          </div>
        </div>
        {/* Send controls */}
        <div className="mb-4 flex flex-wrap gap-2">
          <button
            className="px-3 py-2 bg-gray-700 rounded hover:bg-gray-600 text-sm"
            onClick={() => {
              // Demo: show preview alert for first selected recipient
              const sample = selectedList[0];
              if (!sample) return;
              const sampleCode = generateCertificateCode({ companyPrefix: AURORA_PREFIX, cohort: sample.cohort, fullName: sample.name, issuedAt: new Date(`${sample.issuedAt}T00:00:00Z`), seq: sample.seq });
              const rendered = body
                .replace(/\{\{name\}\}/g, sample.name)
                .replace(/\{\{cohort\}\}/g, sample.cohort)
                .replace(/\{\{cert_code\}\}/g, sampleCode);
              alert(`Test to: ${sample.email}\n\nSubject: ${subject}\n\n${rendered}`);
            }}
            disabled={selectionCount === 0}
          >Send Test</button>
          <button
            className="px-3 py-2 bg-gray-700 rounded hover:bg-gray-600 text-sm flex items-center gap-1"
            onClick={() => {
              navigator.clipboard.writeText(body);
              alert('Template copied to clipboard!');
            }}
            title="Copy email template to clipboard"
          >
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
            Copy Template
          </button>
          <button
            className={`px-3 py-2 rounded text-sm ${canSendEmails ? "bg-[#CCFF00] text-black" : "bg-gray-700 text-gray-400 cursor-not-allowed"}`}
            onClick={() => { if (canSendEmails) void sendRecipients(selectedList); }}
            disabled={!canSendEmails || sending}
          >{sending ? "Sending..." : (recipientMode === "bulk" ? "Send Selected" : "Send Now")}</button>
        </div>
        <div className="grid grid-cols-1 gap-3">
          <div>
            <label className="block text-sm mb-1">Subject</label>
            <input
              className="w-full bg-gray-700 rounded px-3 py-2"
              value={subject}
              onChange={(e) => setSubject(e.target.value)}
              placeholder="Your Aurora Certificate"
            />
          </div>
          <div>
            <label className="block text-sm mb-1">Body</label>
            <textarea
              className="w-full bg-gray-700 rounded px-3 py-2 h-40"
              value={body}
              onChange={(e) => setBody(e.target.value)}
              placeholder="Dear {{name}}, ..."
            />
            <p className="text-xs text-gray-400 mt-1">
              Variables: <code className="bg-gray-900/60 px-1 rounded">{'{{name}}'}</code>,
              {' '}<code className="bg-gray-900/60 px-1 rounded">{'{{position}}'}</code>,
              {' '}<code className="bg-gray-900/60 px-1 rounded">{'{{cohort}}'}</code>,
              {' '}<code className="bg-gray-900/60 px-1 rounded">{'{{cert_code}}'}</code>,
              {' '}<code className="bg-gray-900/60 px-1 rounded">{'{{verify_url}}'}</code>
            </p>
          </div>
        </div>
      </section>

      <section className="mt-6 bg-gray-800 p-4 rounded-lg border border-gray-700">
        <h2 className="text-lg font-semibold mb-3">Certificates</h2>
        <div className="mb-2 flex items-center justify-between gap-2">
          <div className="inline-flex rounded border border-gray-700 overflow-hidden">
            <button className={`px-3 py-1.5 text-xs ${tableView === "database" ? "bg-[#CCFF00] text-black" : "bg-gray-900"}`} onClick={() => setTableView("database")}>Database</button>
            <button className={`px-3 py-1.5 text-xs ${tableView === "import" ? "bg-[#CCFF00] text-black" : "bg-gray-900"}`} onClick={() => setTableView("import")}>Import Preview</button>
          </div>
          <div className="flex items-center gap-2">
            <button
              className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs disabled:opacity-50"
              disabled={importSource.length === 0}
              onClick={() => { setImportHeaders([]); setImportRows([]); setMapName(""); setMapEmail(""); setMapIssuedAt(""); setMapPosition(""); setMapFileName(""); setImportPage(1); setImportDbRows([]); setLastBatchId(null); try { window.localStorage.removeItem('lastImportBatchId'); } catch {} }}
            >Clear Preview</button>
          </div>
          {tableView === "database" ? (
            <div className="flex items-center gap-2">
              <div className="text-xs text-gray-400">Page {page} of {totalPages} • {selectedList.length} rows</div>
              <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => setPage((p) => Math.max(1, p - 1))} disabled={page <= 1}>Prev</button>
              <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => setPage((p) => Math.min(totalPages, p + 1))} disabled={page >= totalPages}>Next</button>
              <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => downloadPdf()}>Download PDF (Page)</button>
              <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => downloadPdfAll()}>Download PDF (All)</button>
            </div>
          ) : (
            <div className="flex items-center gap-2">
              <div className="text-xs text-gray-400">Page {importPage} of {importTotalPages} • {importSource.length} rows</div>
              <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => setImportPage((p) => Math.max(1, p - 1))} disabled={importPage <= 1}>Prev</button>
              <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => setImportPage((p) => Math.min(importTotalPages, p + 1))} disabled={importPage >= importTotalPages}>Next</button>
            </div>
          )}
        </div>
        {tableView === "database" ? (
          <div ref={tableRef} className="overflow-auto">
            <table className="min-w-full text-xs md:text-sm">
              <thead>
                <tr className="text-left text-gray-300">
                  <th className="py-1 pr-3">#</th>
                  <th className="py-1 pr-3">Name</th>
                  <th className="py-1 pr-3">Email</th>
                  <th className="py-1 pr-3 hidden md:table-cell">Position</th>
                  <th className="py-1 pr-3">Cohort</th>
                  <th className="py-1 pr-3">Code</th>
                  <th className="py-1 pr-3">Issued</th>
                  <th className="py-1 pr-3 hidden sm:table-cell">Status</th>
                  <th className="py-1 pr-3 hidden sm:table-cell">File</th>
                  <th className="py-1 pr-3">Sent</th>
                  <th className="py-1 pr-3">Actions</th>
                </tr>
              </thead>
              <tbody>
                {pageItems.map((s, idx) => {
                const sCode = (() => {
                  try {
                    return generateCertificateCode({ companyPrefix: AURORA_PREFIX, cohort: s.cohort, fullName: s.name, issuedAt: new Date(`${s.issuedAt}T00:00:00Z`), seq: s.seq });
                  } catch {
                    return "";
                  }
                })();
                const rank = pageStart + idx + 1;
                return (
                  <tr key={s.id} className="border-t border-gray-700/70">
                    <td className="py-1.5 pr-3 text-gray-400">{rank}</td>
                    <td className="py-1.5 pr-3">{editingId === s.id ? (
                      <input className="w-full bg-gray-700 rounded px-2 py-1" value={editDraft?.name ?? s.name} onChange={(e) => setEditDraft((d) => ({ ...(d ?? s), name: e.target.value }))} />
                    ) : s.name}</td>
                    <td className="py-1.5 pr-3 max-w-[180px] md:max-w-[240px] truncate">{editingId === s.id ? (
                      <input className="w-full bg-gray-700 rounded px-2 py-1" value={editDraft?.email ?? s.email} onChange={(e) => setEditDraft((d) => ({ ...(d ?? s), email: e.target.value }))} />
                    ) : s.email}</td>
                    <td className="py-1.5 pr-3 hidden md:table-cell">{editingId === s.id ? (
                      <input className="w-full bg-gray-700 rounded px-2 py-1" value={editDraft?.position ?? s.position} onChange={(e) => setEditDraft((d) => ({ ...(d ?? s), position: e.target.value }))} />
                    ) : s.position}</td>
                    <td className="py-1.5 pr-3">{editingId === s.id ? (
                      <input className="w-full bg-gray-700 rounded px-2 py-1" value={editDraft?.cohort ?? s.cohort} onChange={(e) => setEditDraft((d) => ({ ...(d ?? s), cohort: e.target.value }))} />
                    ) : s.cohort}</td>
                    <td className="py-1.5 pr-3 font-mono whitespace-nowrap">
                      <button className="underline decoration-dotted hover:opacity-80 text-[11px] md:text-xs" onClick={() => void navigator.clipboard.writeText(sCode)} title="Click to copy code">{sCode}</button>
                    </td>
                    <td className="py-1.5 pr-3">{editingId === s.id ? (
                      <input type="date" className="w-full bg-gray-700 rounded px-2 py-1" value={editDraft?.issuedAt ?? s.issuedAt} onChange={(e) => setEditDraft((d) => ({ ...(d ?? s), issuedAt: e.target.value }))} />
                    ) : s.issuedAt}</td>
                    <td className={`py-1.5 pr-3 hidden sm:table-cell capitalize ${s.status === 'suspended' ? 'text-red-400' : ''}`}>{s.status}</td>
                    <td className="py-1.5 pr-3 hidden sm:table-cell text-gray-200">
                      <div
                        className={`flex items-center gap-2 bg-gray-700 rounded p-2 border ${dragOverId === s.id ? 'border-[#CCFF00] ring-1 ring-[#CCFF00]' : 'border-gray-600'}`}
                        onDragOver={(e) => { e.preventDefault(); if (dragOverId !== s.id) setDragOverId(s.id); }}
                        onDragLeave={() => { if (dragOverId === s.id) setDragOverId(null); }}
                        onDrop={(e) => {
                          e.preventDefault();
                          const f = e.dataTransfer?.files?.[0];
                          if (f) {
                            setFilesById(prev => ({ ...prev, [s.id]: f }));
                            setFileNames(prev => ({ ...prev, [s.id]: f.name }));
                          }
                          setDragOverId(null);
                        }}
                      >
                        <div className="relative">
                          {/* Visible URL field (read-only) that triggers hidden file input */}
                          <input
                            type="text"
                            readOnly
                            value={s.fileUrl || ''}
                            placeholder="No certificate yet. Click to upload."
                            className="block w-full text-xs bg-gray-800 rounded px-2 py-1 cursor-pointer placeholder:text-gray-500"
                            onClick={() => {
                              const el = document.getElementById(`hidden-file-${s.id}`) as HTMLInputElement | null;
                              el?.click();
                            }}
                          />
                          {/* Hidden file input for actual file selection and auto-upload */}
                          <input
                            id={`hidden-file-${s.id}`}
                            key={`file-input-${s.id}-${fileInputKeys[s.id] || 0}`}
                            type="file"
                            className="hidden"
                            accept="application/pdf,image/jpeg,image/png,image/gif,image/webp"
                            onChange={async (e) => {
                              const f = e.target.files?.[0];
                              if (!f) return;
                              try {
                                const fd = new FormData();
                                fd.append('studentId', s.id);
                                if (s.cohort) fd.append('cohort', s.cohort);
                                if (s.issuedAt) fd.append('issuedAt', s.issuedAt);
                                fd.append('displayName', f.name);
                                fd.append('file', f);
                                const resp = await fetch('/api/certificates/file/upload', { method: 'POST', body: fd });
                                const json = await resp.json();
                                if (!resp.ok) { toast(json?.error || 'Upload failed', 'error'); return; }
                                toast('File uploaded', 'success');
                                // refresh students so s.fileUrl shows the new URL
                                await fetchStudents();
                                // refresh Import Preview if a batch is active
                                if (lastBatchId) { void fetchImportBatch(lastBatchId); }
                                // reset file input so re-selecting same file triggers onChange
                                const inputEl = e.target as HTMLInputElement | null;
                                if (inputEl) {
                                  try { inputEl.value = ''; } catch {}
                                }
                                clearFileInputState(s.id);
                              } catch (err) {
                                const msg = typeof err === 'object' && err && 'message' in err ? String((err as {message:unknown}).message) : String(err);
                                toast(`Upload error: ${msg}`, 'error');
                              }
                            }}
                          />
                        </div>
                      </div>
                      {(filesById[s.id]?.name || fileNames[s.id] || s.fileUrl) && (
                        <div className="text-xs text-gray-400 mt-1">
                          {filesById[s.id]?.name || (s.fileUrl && new URL(s.fileUrl).pathname.split('/').pop()) || ''}
                        </div>
                      )}
                      {s.fileUrl && (
                        <div className="text-xs text-gray-300 mt-1">
                          Stored: <a className="underline" href={s.fileUrl} target="_blank" rel="noreferrer">View</a>
                        </div>
                      )}
                      <div className="mt-2 flex flex-wrap gap-2">
                        {/* Upload button removed: upload happens automatically on file choose via the hidden input */}
                        <button
                          className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-[11px] disabled:opacity-50"
                          disabled={!s.fileUrl}
                          onClick={async () => {
                            if (!s.fileUrl) return;
                            if (!confirm('Delete stored file?')) return;
                            try {
                              const resp = await fetch('/api/certificates/file/delete', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ studentId: s.id, fileUrl: s.fileUrl }),
                              });
                              const json = await resp.json();
                              if (!resp.ok) { toast(json?.error || 'Delete failed', 'error'); return; }
                              toast('File deleted', 'success');
                              await fetchStudents();
                              clearFileInputState(s.id);
                              if (lastBatchId) { void fetchImportBatch(lastBatchId); }
                            } catch (e) {
                              const msg = typeof e === 'object' && e && 'message' in e ? String((e as {message:unknown}).message) : String(e);
                              toast(`Delete error: ${msg}`, 'error');
                            }
                          }}
                        >Delete File</button>
                      </div>
                    </td>
                    <td className="py-1.5 pr-3">
                      {(() => {
                        const st = statusesById[s.id] ?? "pending";
                        if (st === "sent") return <span className="text-green-400">Sent</span>;
                        if (st === "failed") return <span className="text-red-400" title={errorsById[s.id] || ""}>Failed</span>;
                        return <span className="text-gray-400">Pending</span>;
                      })()}
                    </td>
                    <td className="py-1.5 pr-3">
                      {editingId === s.id ? (
                        <div className="flex gap-1.5">
                          <button className="px-2 py-0.5 bg-[#CCFF00] text-black rounded text-[11px]" onClick={saveEdit}>Save</button>
                          <button className="px-2 py-0.5 bg-gray-700 rounded hover:bg-gray-600 text-[11px]" onClick={cancelEdit}>Cancel</button>
                        </div>
                      ) : (
                        <div className="inline-block">
                          <button className="px-2 py-0.5 bg-gray-700 rounded hover:bg-gray-600 text-[11px] row-actions" onClick={() => toggleMenu(s.id)}>Actions ▾</button>
                        </div>
                      )}
                    </td>
                  </tr>
                );
              })}
              {recipientMode === "single" && !selectedSingle && (
                <tr className="border-t border-gray-700/70">
                  <td colSpan={11} className="py-6 text-center text-gray-400">Search and select a recipient to preview here.</td>
                </tr>
              )}
            </tbody>
            </table>
          </div>
        ) : (
          <div className="overflow-auto">
            <table className="min-w-full text-xs md:text-sm">
              <thead>
                <tr className="text-left text-gray-300">
                  <th className="py-1 pr-3">#</th>
                  <th className="py-1 pr-3">First Name</th>
                  <th className="py-1 pr-3">Last Name</th>
                  <th className="py-1 pr-3">Email</th>
                  <th className="py-1 pr-3">Cohort</th>
                  <th className="py-1 pr-3">Issued</th>
                  <th className="py-1 pr-3">Generated ID</th>
                  <th className="py-1 pr-3 hidden sm:table-cell">File Name</th>
                  <th className="py-1 pr-3">Actions</th>
                </tr>
              </thead>
              <tbody>
                {importPageItems.map((r: any, idx: number) => {
                  const rank = importPageStart + idx + 1;
                  const isDb = !!r?.id && typeof r?.issued_at === 'string';
                  const first = isDb ? (String(r.name || '').split(/\s+/)[0] || '') : (r.firstName || (r.name?.split(/\s+/)[0] || ""));
                  const last = isDb ? (String(r.name || '').split(/\s+/).slice(1).join(" ") || '') : (r.lastName || (r.name?.split(/\s+/).slice(1).join(" ") || ""));
                  const email = isDb ? r.email : r.email;
                  const cohort = isDb ? r.cohort : r.cohort;
                  const issued = isDb ? r.issued_at : r.issuedAt;
                  const genId = isDb ? (r.cert_code || '') : (previewCodeByIdx[r._idx] || "");
                  const fileName = isDb ? (r.file_display_name || '') : (r.fileName || "");
                  return (
                    <tr key={`${rank}-${email}`} className="border-t border-gray-700/70">
                      <td className="py-1.5 pr-3 text-gray-400">{rank}</td>
                      <td className="py-1.5 pr-3">{first}</td>
                      <td className="py-1.5 pr-3">{last}</td>
                      <td className="py-1.5 pr-3 max-w-[240px] truncate">{email}</td>
                      <td className="py-1.5 pr-3">{cohort}</td>
                      <td className="py-1.5 pr-3">{issued}</td>
                      <td className="py-1.5 pr-3 font-mono whitespace-nowrap">{genId}</td>
                      <td className="py-1.5 pr-3 hidden sm:table-cell">{fileName}</td>
                      <td className="py-1.5 pr-3">
                        {isDb ? (
                          <div className="inline-block">
                            <button className="px-2 py-0.5 bg-gray-700 rounded hover:bg-gray-600 text-[11px] row-actions" onClick={() => toggleMenu(r.id)}>Actions ▾</button>
                          </div>
                        ) : (
                          <div className="relative inline-block">
                            <button className="px-2 py-0.5 bg-gray-700 rounded hover:bg-gray-600 text-[11px] row-actions" onClick={() => setPreviewMenuIdx(prev => prev === rank ? null : rank)}>Actions ▾</button>
                            {previewMenuIdx === rank && (
                              <div className="absolute z-10 mt-1 w-40 bg-gray-900 border border-gray-700 rounded shadow">
                                <button className="w-full text-left px-3 py-1.5 hover:bg-gray-800 text-[12px]" onClick={async () => {
                                  try {
                                    const body = { cohort, rows: [{ name: r.name, email: r.email, issuedAt: issued, position: undefined, fileName }] };
                                    const resp = await fetch('/api/certificates/import', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
                                    const json = await resp.json();
                                    if (!resp.ok) { toast(json?.error || 'Import failed', 'error'); return; }
                                    const bid = json?.batchId ? String(json.batchId) : null;
                                    if (bid) { try { window.localStorage.setItem('lastImportBatchId', bid); } catch {} setLastBatchId(bid); void fetchImportBatch(bid); }
                                    toast('Row imported', 'success');
                                    setImportRows(prev => prev.filter((_, i) => i !== r._idx));
                                    setPreviewMenuIdx(null);
                                    void fetchStudents();
                                  } catch (e) {
                                    const msg = typeof e === 'object' && e && 'message' in e ? String((e as {message:unknown}).message) : String(e);
                                    toast(`Error: ${msg}`, 'error');
                                  }
                                }}>Import Row</button>
                                <button className="w-full text-left px-3 py-1.5 hover:bg-gray-800 text-[12px]" onClick={() => { setImportRows(prev => prev.filter((_, i) => i !== r._idx)); setPreviewMenuIdx(null); }}>Remove</button>
                              </div>
                            )}
                          </div>
                        )}
                      </td>
                    </tr>
                  );
                })}
                {importMapped.length === 0 && (
                  <tr className="border-t border-gray-700/70"><td colSpan={8} className="py-6 text-center text-gray-400">Upload and map a CSV/XLSX to preview here.</td></tr>
                )}
              </tbody>
            </table>
            <div className="mt-3 flex items-center justify-between gap-2">
              <div className="text-xs text-gray-400">Showing {importPageStart + 1}-{Math.min(importPageStart + PAGE_SIZE, importSource.length)} of {importSource.length}</div>
              <div className="flex items-center gap-2">
                <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => setImportPage((p) => Math.max(1, p - 1))} disabled={importPage <= 1}>Prev</button>
                <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => setImportPage((p) => Math.min(importTotalPages, p + 1))} disabled={importPage >= importTotalPages}>Next</button>
              </div>
            </div>
          </div>
        )}
      </section>
      {/* Preview Modal */}
      {previewOpen && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
          <div className="w-full max-w-xl bg-gray-800 border border-gray-700 rounded-lg p-4">
            <div className="flex items-center justify-between mb-3">
              <h3 className="font-semibold">Preview</h3>
              <button className="text-gray-300 hover:text-white" onClick={() => setPreviewOpen(false)}>Close</button>
            </div>
            <div className="text-sm text-gray-400 mb-2">To: {previewTo}</div>
            <div className="mb-2">
              <label className="block text-sm mb-1 text-gray-300">Subject</label>
              <input
                className="w-full bg-gray-900 rounded px-3 py-2 text-sm"
                value={previewSubject}
                onChange={(e) => setPreviewSubject(e.target.value)}
              />
            </div>
            <div className="mb-3">
              <label className="block text-sm mb-1 text-gray-300">Body</label>
              <textarea
                className="w-full bg-gray-900 rounded px-3 py-2 text-sm h-56"
                value={previewBody}
                onChange={(e) => setPreviewBody(e.target.value)}
              />
            </div>
            <div className="flex justify-end gap-2">
              <button
                className="px-3 py-2 bg-gray-700 rounded hover:bg-gray-600 text-sm"
                onClick={() => setPreviewOpen(false)}
              >Cancel</button>
              <button
                className="px-3 py-2 bg-[#CCFF00] text-black rounded text-sm"
                onClick={() => { setSubject(previewSubject); setPreviewOpen(false); }}
              >Save Changes</button>
            </div>
          </div>
        </div>
      )}
      {/* Toast UI */}
      <div className="fixed top-3 right-3 z-50 space-y-2">
        {toasts.map((t) => (
          <div key={t.id} className={`px-3 py-2 rounded text-sm shadow border ${t.type === 'success' ? 'bg-green-700/80 border-green-500' : t.type === 'error' ? 'bg-red-700/80 border-red-500' : 'bg-gray-700/80 border-gray-500'}`}>
            {t.text}
          </div>
        ))}
      </div>
      {/* Centered actions modal */}
      {openMenuId && openMenuRow && (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 bg-black/50" />
          <div id="actions-popover" className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[280px] max-w-[92vw] bg-gray-900 border border-gray-700 rounded-lg shadow-2xl">
            <div className="px-4 py-3 border-b border-gray-800 flex items-center justify-between">
              <div className="text-sm text-gray-300">Actions</div>
              <button className="text-gray-400 hover:text-white" onClick={() => setOpenMenuId(null)}>✕</button>
            </div>
            <div className="py-1">
              <button className="w-full text-left px-4 py-2 hover:bg-gray-800 text-[13px]" onClick={() => { void copyCode(openMenuRow); setOpenMenuId(null); }}>Copy Code</button>
              <button className="w-full text-left px-4 py-2 hover:bg-gray-800 text-[13px]" onClick={() => { openPreview(openMenuRow); setOpenMenuId(null); }}>Preview</button>
              <button className="w-full text-left px-4 py-2 hover:bg-gray-800 text-[13px]" onClick={() => { startEdit(openMenuRow.id); setOpenMenuId(null); }}>Edit</button>
              <button className="w-full text-left px-4 py-2 hover:bg-gray-800 text-[13px]" onClick={() => { toggleSuspend(openMenuRow.id); setOpenMenuId(null); }}>{openMenuRow.status === 'suspended' ? 'Unsuspend' : 'Suspend'}</button>
              <button className="w-full text-left px-4 py-2 hover:bg-gray-800 text-[13px] text-red-300" onClick={() => { void deleteRow(openMenuRow.id); setOpenMenuId(null); }}>Delete</button>
              <button
                className="w-full text-left px-4 py-2 hover:bg-gray-800 text-[13px]"
                onClick={() => {
                  if (sending) return;
                  if (!filesById[openMenuRow.id] && !openMenuRow.fileUrl) {
                    toast("Please attach a file to this row before sending.", "error");
                    return;
                  }
                  void sendRecipients([openMenuRow]);
                  setOpenMenuId(null);
                }}
              >Send Email</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
