"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { getBrowserSupabase } from "@/lib/supabase/browser";
import { generateCertificateCode } from "@/lib/certificates/code";

const AURORA_PREFIX = "AURORA";

type StudentInput = {
  name: string;
  email: string;
  position: string;
  cohort: string;
  issuedAt: string; // yyyy-MM-dd
};

type StudentRow = StudentInput & {
  id: string;
  seq: number;
  status: "active" | "suspended";
  fileUrl?: string | null;
};

const defaultRow: StudentInput = {
  name: "Amaka Umeh",
  email: "amaka@example.com",
  position: "Robotics Engineer",
  cohort: "CORE2",
  issuedAt: new Date().toISOString().slice(0, 10),
};

export default function CertificatesAdminPage() {
  const [mode, setMode] = useState<"manual" | "auto">("manual");
  const [row, setRow] = useState<StudentInput>(defaultRow);
  // Sequence will be auto-generated by the system in batch; keep internal for preview only
  const [seq] = useState<number>(1);
  // Compose inputs
  const [subject, setSubject] = useState<string>(
    "Certificate of Participation — Aurora Robotics Core Workshop 1.0"
  );
  const [body, setBody] = useState<string>(
    `Dear {{name}},

Thank you for being part of the Aurora Robotics
Core Workshop 1.0. We appreciate your time,
commitment, and active participation 
throughout the workshop.

Please find attached your Certificate of 
Participation. We hope the experience was 
insightful and that the skills gained will support
your learning and future projects.

Warm regards,
Aurora Robotics.`
  );
  // Track file names for display
  const [fileNames, setFileNames] = useState<Record<string, string>>({});

  // Recipient mode and data
  const [recipientMode, setRecipientMode] = useState<"bulk" | "single">("bulk");

  // Track per-recipient selected file object
  const [filesById, setFilesById] = useState<Record<string, File | undefined>>({});
  const [fileInputKeys, setFileInputKeys] = useState<Record<string, number>>({});

  // Initialize file names from stored URLs when students data is loaded
  const initializeFileNames = useCallback((studentsList: StudentRow[]) => {
    const initialFileNames = studentsList.reduce((acc: Record<string, string>, student) => {
      if (student.fileUrl) {
        try {
          const url = new URL(student.fileUrl);
          acc[student.id] = url.pathname.split('/').pop() || '';
        } catch (e) {
          console.error('Invalid file URL:', student.fileUrl);
        }
      }
      return acc;
    }, {});
    setFileNames(prev => ({ ...prev, ...initialFileNames }));
  }, []);

  // Save file input states to localStorage when they change
  useEffect(() => {
    if (Object.keys(fileInputKeys).length > 0) {
      localStorage.setItem('certificateFileInputs', JSON.stringify(fileInputKeys));
    }
  }, [fileInputKeys]);

  const updateFileInputState = useCallback((studentId: string) => {
    setFileInputKeys(prev => ({
      ...prev,
      [studentId]: (prev[studentId] || 0) + 1
    }));
  }, []);

  const clearFileInputState = useCallback((studentId: string) => {
    setFileInputKeys(prev => {
      const newState = { ...prev };
      delete newState[studentId];
      return newState;
    });
    setFileNames(prev => {
      const newState = { ...prev };
      delete newState[studentId];
      return newState;
    });
  }, []);

  // Define StudentRow type
  type StudentRow = {
    id: string;
    name: string;
    email: string;
    position: string;
    cohort: string;
    issuedAt: string;
    fileUrl?: string | null;
  };

  // minimal toast system (placed before fetch to avoid use-before-declare)
  type Toast = { id: number; type: "success" | "error" | "info"; text: string };
  const [toasts, setToasts] = useState<Toast[]>([]);
  const toast = useCallback((text: string, type: Toast["type"] = "info") => {
    const id = Date.now() + Math.random();
    setToasts((t) => [...t, { id, type, text }]);
    setTimeout(() => setToasts((t) => t.filter((x) => x.id !== id)), 3500);
  }, []);

  // Live dataset from DB
  const [studentList, setStudentList] = useState<StudentRow[]>([]);
  type SupaStudentRow = { id: string; name: string; email: string; position: string; cohort: string; issued_at: string; seq: number; status: "active" | "suspended"; file_url?: string | null };
  const fetchStudents = useCallback(async () => {
    const sb = getBrowserSupabase();
    const { data, error } = await sb
      .from("students")
      .select("id,name,email,position,cohort,issued_at,seq,status,file_url")
      .order("created_at", { ascending: false });
    if (error) {
      toast(`Load failed: ${error.message}`, "error");
      return;
    }
    const rows: StudentRow[] = (data as SupaStudentRow[] | null)?.map((d) => ({
      id: d.id,
      name: d.name,
      email: d.email,
      position: d.position,
      cohort: d.cohort,
      issuedAt: d.issued_at,
      seq: d.seq,
      status: d.status,
      fileUrl: d.file_url ?? null,
    })) ?? [];
    setStudentList(rows);
  }, [toast]);
  useEffect(() => { void fetchStudents(); }, [fetchStudents]);

  // Bulk filters
  const [filterCohorts, setFilterCohorts] = useState<string[]>([]);
  const [filterYears, setFilterYears] = useState<string[]>([]);
  const [filterStatuses, setFilterStatuses] = useState<Array<"active" | "suspended">>([]);
  const [filterSearch, setFilterSearch] = useState<string>("");

  const availableCohorts = useMemo(() => Array.from(new Set(studentList.map(s => s.cohort))).sort(), [studentList]);
  const availableYears = useMemo(() => Array.from(new Set(studentList.map(s => s.issuedAt.slice(0,4)))).sort(), [studentList]);

  const filteredStudents = useMemo(() => {
    return studentList.filter((s) => {
      const byCohort = filterCohorts.length === 0 || filterCohorts.includes(s.cohort);
      const year = s.issuedAt.slice(0,4);
      const byYear = filterYears.length === 0 || filterYears.includes(year);
      const byStatus = filterStatuses.length === 0 || filterStatuses.includes(s.status);
      const q = filterSearch.trim().toLowerCase();
      const bySearch = q.length === 0
        || s.name.toLowerCase().includes(q)
        || s.email.toLowerCase().includes(q)
        || s.cohort.toLowerCase().includes(q)
        || (s.status === "active" && "active".includes(q))
        || (s.status === "suspended" && "suspended".includes(q));
      return byCohort && byYear && byStatus && bySearch;
    });
  }, [studentList, filterCohorts, filterYears, filterStatuses, filterSearch]);

  // Single search
  const [singleQuery, setSingleQuery] = useState<string>("");
  const [selectedSingleId, setSelectedSingleId] = useState<string | null>(null);
  const singleSuggestions = useMemo(() => {
    const q = singleQuery.trim().toLowerCase();
    if (!q) return [] as StudentRow[];
    return studentList.filter(s => s.name.toLowerCase().includes(q) || s.email.toLowerCase().includes(q) || s.cohort.toLowerCase().includes(q)).slice(0,5);
  }, [studentList, singleQuery]);
  const selectedSingle = useMemo(() => studentList.find(s => s.id === selectedSingleId) || null, [studentList, selectedSingleId]);

  // Pagination for table
  const PAGE_SIZE = 10;
  const [page, setPage] = useState<number>(1);
  // Reset page only when mode or filters change (not when filtered array identity changes)
  useEffect(() => {
    setPage(1);
  }, [recipientMode, filterCohorts, filterYears, filterStatuses, filterSearch, selectedSingleId]);
  // Clamp page to valid range when list size changes
  useEffect(() => {
    const currentLen = recipientMode === "bulk"
      ? filteredStudents.length
      : (selectedSingleId ? 1 : 0);
    const totalPagesNext = Math.max(1, Math.ceil(currentLen / PAGE_SIZE));
    if (page > totalPagesNext) setPage(totalPagesNext);
  }, [recipientMode, filteredStudents.length, selectedSingleId, PAGE_SIZE, page]);

  // Row editing state
  const [editingId, setEditingId] = useState<string | null>(null);
  const [editDraft, setEditDraft] = useState<StudentInput | null>(null);
  const startEdit = (id: string) => {
    const s = studentList.find((x) => x.id === id);
    if (!s) return;
    setEditingId(id);
    setEditDraft({ name: s.name, email: s.email, position: s.position, cohort: s.cohort, issuedAt: s.issuedAt });
  };

  // Row actions dropdown state
  const [openMenuId, setOpenMenuId] = useState<string | null>(null);
  const toggleMenu = (id: string) => {
    setOpenMenuId((cur) => (cur === id ? null : id));
  };

  // Close dropdown on outside click and on Escape
  useEffect(() => {
    function onDocClick(e: MouseEvent) {
      if (!openMenuId) return;
      const t = e.target as HTMLElement | null;
      if (!t) return;
      const inActions = t.closest('.row-actions') || t.closest('#actions-popover');
      if (!inActions) setOpenMenuId(null);
    }
    function onKey(e: KeyboardEvent) {
      if (e.key === 'Escape') setOpenMenuId(null);
    }
    document.addEventListener('mousedown', onDocClick);
    document.addEventListener('keydown', onKey);
    return () => {
      document.removeEventListener('mousedown', onDocClick);
      document.removeEventListener('keydown', onKey);
    };
  }, [openMenuId]);

  // Row for the open menu (if any)
  const openMenuRow = useMemo(() => studentList.find((s) => s.id === openMenuId) || null, [studentList, openMenuId]);


  async function copyCode(s: StudentRow) {
    try {
      const { code } = renderBodyFor(s);
      await navigator.clipboard.writeText(code);
      toast("Code copied", "success");
    } catch (e) {
      const msg = typeof e === "object" && e && "message" in e ? String((e as { message: unknown }).message) : String(e);
      toast(`Copy failed: ${msg}`, "error");
    }
  }
  const saveEdit = async () => {
    if (!editingId || !editDraft) return;
    const current = studentList.find((s) => s.id === editingId);
    if (!current) return;
    const merged: StudentRow = { ...current, ...editDraft } as StudentRow;
    await saveRow(merged);
    setEditingId(null);
    setEditDraft(null);
  };
  const cancelEdit = () => {
    setEditingId(null);
    setEditDraft(null);
  };
  const toggleSuspend = (id: string) => {
    setStudentList((list) => list.map((s) => (s.id === id ? { ...s, status: s.status === "suspended" ? "active" : "suspended" } : s)));
    // Demo notification
    const s = studentList.find((x) => x.id === id);
    if (s) {
      const action = s.status === "suspended" ? "re-activated" : "suspended";
      alert(`A notification email would be sent to ${s.email}: account ${action}.`);
    }
  };
  const deleteRow = async (id: string) => {
    if (!confirm("Delete this student?")) return;
    try {
      const resp = await fetch("/api/certificates/delete", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ id }),
      });
      const json = await resp.json();
      if (!resp.ok) {
        toast(`Delete failed: ${json?.error || resp.status}`, "error");
        return;
      }
      toast("Deleted", "success");
      void fetchStudents();
    } catch (e) {
      const msg = typeof e === "object" && e && "message" in e ? String((e as { message: unknown }).message) : String(e);
      toast(`Error: ${msg}`, "error");
    }
  };

  // Preview modal state
  const [previewOpen, setPreviewOpen] = useState(false);
  const [previewTo, setPreviewTo] = useState<string>("");
  const [previewSubject, setPreviewSubject] = useState<string>("");
  const [previewBody, setPreviewBody] = useState<string>("");
  const openPreview = (s: StudentRow) => {
    const sCode = generateCertificateCode({ companyPrefix: AURORA_PREFIX, cohort: s.cohort, fullName: s.name, issuedAt: new Date(`${s.issuedAt}T00:00:00Z`), seq: s.seq });
    const rendered = body
      .replace(/\{\{name\}\}/g, s.name)
      .replace(/\{\{position\}\}/g, s.position)
      .replace(/\{\{cohort\}\}/g, s.cohort)
      .replace(/\{\{cert_code\}\}/g, sCode)
      .replace(/\{\{verify_url\}\}/g, `https://aurora.example/verify/${encodeURIComponent(sCode)}`);
    setPreviewTo(s.email);
    setPreviewSubject(subject);
    setPreviewBody(rendered);
    setPreviewOpen(true);
  };

  // Current selection list based on mode
  const selectedList: StudentRow[] = useMemo(() => {
    return recipientMode === "bulk" ? filteredStudents : selectedSingle ? [selectedSingle] : [];
  }, [recipientMode, filteredStudents, selectedSingle]);

  const pageStart = (page - 1) * PAGE_SIZE;
  const pageItems = useMemo(() => selectedList.slice(pageStart, pageStart + PAGE_SIZE), [selectedList, pageStart]);
  const totalPages = Math.max(1, Math.ceil(selectedList.length / PAGE_SIZE));

  // Print/PDF via hidden iframe (avoids popup blockers)
  const tableRef = useRef<HTMLDivElement | null>(null);
  function printHtml(html: string) {
    const iframe = document.createElement("iframe");
    iframe.style.position = "fixed";
    iframe.style.left = "-9999px";
    iframe.style.top = "0";
    iframe.width = "0";
    iframe.height = "0";
    document.body.appendChild(iframe);
    const doc = iframe.contentWindow?.document;
    if (!doc) { document.body.removeChild(iframe); return; }
    doc.open();
    doc.write(`<!doctype html><html><head><meta charset=\"utf-8\"/><title>Certificates</title>
      <style>
        body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;background:#fff;color:#111;padding:16px}
        table{width:100%;border-collapse:collapse;font-size:12px}
        th,td{border:1px solid #ddd;padding:6px}
        thead th{background:#f3f4f6;position:sticky;top:0}
        .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
      </style></head><body>${html}</body></html>`);
    doc.close();
    const w = iframe.contentWindow;
    setTimeout(() => {
      try { w?.focus(); w?.print(); } catch {}
      setTimeout(() => { document.body.removeChild(iframe); }, 300);
    }, 50);
  }
  function downloadPdf() {
    try {
      const html = tableRef.current ? tableRef.current.innerHTML : "";
      printHtml(html);
    } catch {}
  }
  function downloadPdfAll() {
    try {
      const rows = selectedList;
      const headers = ["#","Name","Email","Position","Cohort","Code","Issued","Status"];
      const bodyRows = rows.map((s, i) => {
        let code = "";
        try { code = generateCertificateCode({ companyPrefix: AURORA_PREFIX, cohort: s.cohort, fullName: s.name, issuedAt: new Date(`${s.issuedAt}T00:00:00Z`), seq: s.seq }); } catch {}
        return [String(i+1), s.name, s.email, s.position, s.cohort, code, s.issuedAt, s.status];
      });
      const tableHtml = `
        <h1 style=\"margin:0 0 12px 0;font-size:16px\">Certificates Export (${rows.length} rows)</h1>
        <table>
          <thead><tr>${headers.map(h=>`<th>${h}</th>`).join("")}</tr></thead>
          <tbody>
            ${bodyRows.map(r=>`<tr>${r.map(c=>`<td>${String(c).replace(/&/g,'&amp;').replace(/</g,'&lt;')}</td>`).join("")}</tr>`).join("")}
          </tbody>
        </table>`;
      printHtml(tableHtml);
    } catch (e) {
      const msg = typeof e === 'object' && e && 'message' in e ? String((e as {message:unknown}).message) : String(e);
      toast(`Export failed: ${msg}`, "error");
    }
  }

  // Preflight validation
  const missingAttachments = useMemo(() => {
    return selectedList.filter((s) => !filesById[s.id] && !s.fileUrl).map((s) => s.id);
  }, [selectedList, filesById]);
  const hasSubject = subject.trim().length > 0;
  const hasBody = body.trim().length > 0;
  const selectionCount = selectedList.length;
  const canSend = selectionCount > 0 && hasSubject && hasBody && missingAttachments.length === 0;

  // Throttling estimate (from env; default 300)
  const dailyCap = Number(process.env.NEXT_PUBLIC_EMAIL_DAILY_CAP || 300);
  const estimatedDays = selectionCount === 0 ? 0 : Math.ceil(selectionCount / dailyCap);

  // Helpers for sending
  async function fileToBase64(file: File): Promise<string> {
    const arrayBuffer = await file.arrayBuffer();
    const bytes = new Uint8Array(arrayBuffer);
    let binary = "";
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }
  async function urlToBase64(url: string): Promise<string> {
    const resp = await fetch(url);
    const blob = await resp.blob();
    const arrayBuffer = await blob.arrayBuffer();
    const bytes = new Uint8Array(arrayBuffer);
    let binary = "";
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  function renderBodyFor(s: StudentRow): { rendered: string; code: string } {
    const sCode = generateCertificateCode({ companyPrefix: AURORA_PREFIX, cohort: s.cohort, fullName: s.name, issuedAt: new Date(`${s.issuedAt}T00:00:00Z`), seq: s.seq });
    const rendered = body
      .replace(/\{\{name\}\}/g, s.name)
      .replace(/\{\{position\}\}/g, s.position)
      .replace(/\{\{cohort\}\}/g, s.cohort)
      .replace(/\{\{cert_code\}\}/g, sCode)
      .replace(/\{\{verify_url\}\}/g, `https://aurora.example/verify/${encodeURIComponent(sCode)}`);
    return { rendered, code: sCode };
  }

  const [sending, setSending] = useState(false);
  const [lastResult, setLastResult] = useState<string>("");
  const [statusesById, setStatusesById] = useState<Record<string, "pending" | "sent" | "failed">>({});
  const [errorsById, setErrorsById] = useState<Record<string, string>>({});
  const [dragOverId, setDragOverId] = useState<string | null>(null);

  function toHtml(src: string): string {
    const esc = src.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    const blocks = esc.split(/\n\s*\n/);
    return blocks.map((b) => `<p>${b.replace(/\n/g, '<br/>')}</p>`).join("\n");
  }


  type SendResult = { email: string; ok: boolean; id?: string; error?: string };

  async function saveRow(s: StudentRow) {
    // Client-side duplicate checks
    const existsSameKey = studentList.find((x) => x.id !== s.id && x.email === s.email && x.cohort === s.cohort && x.issuedAt === s.issuedAt);
    if (existsSameKey) {
      toast("Duplicate (email + cohort + date) exists. Edit that row instead.", "error");
      return;
    }
    try {
      const resp = await fetch("/api/certificates/save", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          id: s.id && s.id.length === 36 ? s.id : undefined,
          name: s.name,
          email: s.email,
          position: s.position,
          cohort: s.cohort,
          issuedAt: s.issuedAt,
          seq: s.seq,
          status: s.status,
        }),
      });
      const json = await resp.json();
      if (!resp.ok) {
        toast(`Save failed: ${json?.error || resp.status}`, "error");
        return;
      }
      toast("Saved", "success");
      void fetchStudents();
    } catch (e) {
      const msg = typeof e === "object" && e && "message" in e ? String((e as { message: unknown }).message) : String(e);
      toast(`Error: ${msg}`, "error");
    }
  }

  // removed per user request: Add All

  async function sendRecipients(recipients: StudentRow[]) {
    setSending(true);
    setLastResult("");
    // initialize pending status for those being sent now
    setStatusesById((prev) => {
      const copy = { ...prev };
      for (const s of recipients) copy[s.id] = "pending";
      return copy;
    });
    try {
      const items = await Promise.all(
        recipients.map(async (s) => {
          const { rendered, code } = renderBodyFor(s);
          const f = filesById[s.id];
          let attachments: { name: string; contentBase64: string }[] = [];
          if (f) {
            attachments = [{ name: f.name, contentBase64: await fileToBase64(f) }];
          } else if (s.fileUrl) {
            try {
              const base64 = await urlToBase64(s.fileUrl);
              const guessedName = decodeURIComponent(s.fileUrl.split('/').pop() || 'certificate.pdf');
              attachments = [{ name: guessedName, contentBase64: base64 }];
            } catch {}
          }
          return {
            email: s.email,
            name: s.name,
            subject,
            body: toHtml(rendered),
            attachments,
            meta: { cert_code: code, student_id: s.id },
          };
        })
      );

      const resp = await fetch("/api/email/send", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ recipients: items }),
      });
      const json = (await resp.json()) as { results?: SendResult[]; error?: string };
      if (!resp.ok) {
        toast(`Send failed: ${json?.error || resp.status}`, "error");
      } else {
        const results = Array.isArray(json?.results) ? json.results : [];
        // map results back to ids by email
        setStatusesById((prev) => {
          const copy = { ...prev };
          for (const s of recipients) {
            const r = results.find((x) => x.email === s.email);
            if (r) copy[s.id] = r.ok ? "sent" : "failed";
          }
          return copy;
        });
        setErrorsById((prev) => {
          const copy = { ...prev };
          for (const s of recipients) {
            const r = results.find((x) => x.email === s.email);
            if (r && !r.ok && r.error) copy[s.id] = r.error;
          }
          return copy;
        });
        const ok = results.filter((r) => r.ok).length;
        const fail = results.length - ok;
        setLastResult(`Sent: ${ok}, Failed: ${fail}`);
        toast(`Send complete. ${ok} sent, ${fail} failed.`, "success");
      }
    } catch (e: unknown) {
      const msg = typeof e === "object" && e && "message" in e ? String((e as { message: unknown }).message) : String(e);
      toast(`Error: ${msg}`, "error");
    } finally {
      setSending(false);
    }
  }

  const code = useMemo(() => {
    try {
      const d = new Date(`${row.issuedAt}T00:00:00Z`);
      return generateCertificateCode({
        companyPrefix: AURORA_PREFIX,
        cohort: row.cohort,
        fullName: row.name,
        issuedAt: d,
        seq,
      });
    } catch {
      return "";
    }
  }, [row, seq]);

  return (
    <div className="min-h-screen bg-gray-900 text-white p-6">
      <header className="mb-6 flex items-center justify-between">
        <h1 className="text-2xl font-bold">Certificates</h1>
        <div className="inline-flex rounded border border-gray-700 overflow-hidden">
          <button
            className={`px-3 py-1.5 text-sm ${mode === "manual" ? "bg-[#CCFF00] text-black" : "bg-gray-800"}`}
            onClick={() => setMode("manual")}
          >Manual</button>
          <button
            className={`px-3 py-1.5 text-sm ${mode === "auto" ? "bg-[#CCFF00] text-black" : "bg-gray-800"}`}
            onClick={() => setMode("auto")}
          >Auto</button>
        </div>
      </header>

      <section className="bg-gray-800 p-4 rounded-lg border border-gray-700">
        <h2 className="text-lg font-semibold mb-3">Generate code</h2>
        <p className="text-gray-300 text-sm mb-4">Format: AURORA-&lt;COHORT&gt;-NAM3-YYMM-SEQ-CHK</p>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
          <div>
            <label className="block text-sm mb-1">Full Name</label>
            <input
              className="w-full bg-gray-700 rounded px-3 py-2"
              value={row.name}
              onChange={(e) => setRow((r) => ({ ...r, name: e.target.value }))}
              placeholder="Student full name"
            />
          </div>
          <div>
            <label className="block text-sm mb-1">Email</label>
            <input
              className="w-full bg-gray-700 rounded px-3 py-2"
              value={row.email}
              onChange={(e) => setRow((r) => ({ ...r, email: e.target.value }))}
              placeholder="student@email.com"
            />
          </div>
          <div>
            <label className="block text-sm mb-1">Position/Title</label>
            <input
              className="w-full bg-gray-700 rounded px-3 py-2"
              value={row.position}
              onChange={(e) => setRow((r) => ({ ...r, position: e.target.value }))}
              placeholder="e.g., Robotics Engineer"
            />
          </div>
          <div>
            <label className="block text-sm mb-1">Cohort</label>
            <input
              className="w-full bg-gray-700 rounded px-3 py-2"
              value={row.cohort}
              onChange={(e) => setRow((r) => ({ ...r, cohort: e.target.value.toUpperCase() }))}
              placeholder="CORE2"
            />
          </div>
          <div>
            <label className="block text-sm mb-1">Issued At</label>
            <input
              type="date"
              className="w-full bg-gray-700 rounded px-3 py-2"
              value={row.issuedAt}
              onChange={(e) => setRow((r) => ({ ...r, issuedAt: e.target.value }))}
            />
          </div>
        </div>
        <div className="mt-4 p-3 bg-gray-900/50 rounded border border-gray-700">
          <div className="text-sm text-gray-400 mb-1">Generated Code</div>
          <div className="font-mono select-all break-all">{code || "—"}</div>
        </div>
        <div className="mt-3 flex gap-2">
          <button
            className="px-3 py-2 bg-[#CCFF00] text-black rounded text-sm"
            onClick={() => void saveRow({
              // no id here so API creates a new row
              id: "", // ignored by API due to length check
              name: row.name,
              email: row.email,
              position: row.position,
              cohort: row.cohort,
              issuedAt: row.issuedAt,
              seq,
              status: "active",
            } as StudentRow)}
            title="Add this certificate row to the database"
          >Add</button>
          <span className="text-xs text-gray-400 self-center">Saves to database and appears in the table below.</span>
        </div>
        <p className="text-xs text-gray-400 mt-2">
          Manual mode: paste this code into your certificate design, export PDF/PNG, and upload.
          Auto mode: the system will place this code on your template automatically (when template is configured).
        </p>
      </section>

      {/* Compose section for bulk/single send */}
      <section className="mt-6 bg-gray-800 p-4 rounded-lg border border-gray-700">
        <h2 className="text-lg font-semibold mb-3">Compose Email</h2>
        <div className="mb-3 flex items-center gap-3">
          <div className="text-sm text-gray-300">Recipient Mode:</div>
          <div className="inline-flex rounded border border-gray-700 overflow-hidden">
            <button className={`px-3 py-1.5 text-sm ${recipientMode === "bulk" ? "bg-[#CCFF00] text-black" : "bg-gray-900"}`} onClick={() => setRecipientMode("bulk")}>Bulk</button>
            <button className={`px-3 py-1.5 text-sm ${recipientMode === "single" ? "bg-[#CCFF00] text-black" : "bg-gray-900"}`} onClick={() => setRecipientMode("single")}>Single</button>
          </div>
          {recipientMode === "bulk" && <div className="ml-auto text-sm text-gray-400">Matched: {filteredStudents.length}</div>}
          {recipientMode === "single" && <div className="ml-auto text-sm text-gray-400">{selectedSingle ? selectedSingle.email : "No recipient selected"}</div>}
          <button
            className={`ml-2 px-3 py-1.5 rounded text-sm ${recipientMode === "bulk" && canSend ? "bg-[#CCFF00] text-black" : "bg-gray-700 text-gray-400 cursor-not-allowed"}`}
            onClick={() => { if (recipientMode === "bulk" && canSend) void sendRecipients(selectedList); }}
            disabled={recipientMode !== "bulk" || !canSend || sending}
            title="Send to all currently matched recipients"
          >
            {sending ? "Sending..." : "Send All (Bulk)"}
          </button>
        </div>

        {recipientMode === "bulk" && (
          <div className="mb-4 grid grid-cols-1 md:grid-cols-3 gap-3">
            <div>
              <label className="block text-sm mb-1">Cohort</label>
              <div className="flex flex-wrap gap-2 bg-gray-700 rounded p-2">
                {availableCohorts.map((c) => {
                  const checked = filterCohorts.includes(c);
                  return (
                    <label key={c} className="flex items-center gap-1 text-sm">
                      <input type="checkbox" className="accent-[#CCFF00]" checked={checked} onChange={(e) => setFilterCohorts(prev => e.target.checked ? [...prev, c] : prev.filter(x => x !== c))} />
                      <span>{c}</span>
                    </label>
                  );
                })}
              </div>
            </div>
            <div>
              <label className="block text-sm mb-1">Year</label>
              <div className="flex flex-wrap gap-2 bg-gray-700 rounded p-2">
                {availableYears.map((y) => {
                  const checked = filterYears.includes(y);
                  return (
                    <label key={y} className="flex items-center gap-1 text-sm">
                      <input type="checkbox" className="accent-[#CCFF00]" checked={checked} onChange={(e) => setFilterYears(prev => e.target.checked ? [...prev, y] : prev.filter(x => x !== y))} />
                      <span>{y}</span>
                    </label>
                  );
                })}
              </div>
            </div>
            <div>
              <label className="block text-sm mb-1">Search</label>
              <input className="w-full bg-gray-700 rounded px-3 py-2" value={filterSearch} onChange={(e) => setFilterSearch(e.target.value)} placeholder="Search name, email, cohort" />
            </div>
            <div className="md:col-span-3">
              <label className="block text-sm mb-1">Status</label>
              <div className="flex flex-wrap gap-2 bg-gray-700 rounded p-2">
                {(["active", "suspended"] as Array<"active" | "suspended">).map((st) => {
                  const checked = filterStatuses.includes(st);
                  return (
                    <label key={st} className="flex items-center gap-1 text-sm">
                      <input
                        type="checkbox"
                        className="accent-[#CCFF00]"
                        checked={checked}
                        onChange={(e) =>
                          setFilterStatuses((prev) =>
                            e.target.checked ? [...prev, st] : prev.filter((x) => x !== st)
                          )
                        }
                      />
                      <span className="capitalize">{st}</span>
                    </label>
                  );
                })}
              </div>
            </div>
          </div>
        )}

        {recipientMode === "single" && (
          <div className="mb-4">
            <label className="block text-sm mb-1">Find Recipient</label>
            <input className="w-full bg-gray-700 rounded px-3 py-2" value={singleQuery} onChange={(e) => setSingleQuery(e.target.value)} placeholder="Type name, email, cohort..." />
            {singleQuery && singleSuggestions.length > 0 && (
              <div className="mt-2 bg-gray-900 border border-gray-700 rounded divide-y divide-gray-800">
                {singleSuggestions.map((s) => (
                  <button key={s.id} className="w-full text-left px-3 py-2 hover:bg-gray-800" onClick={() => { setSelectedSingleId(s.id); setSingleQuery(""); }}>
                    <div className="text-sm">{s.name} <span className="text-gray-400">({s.email})</span></div>
                    <div className="text-xs text-gray-400">Cohort {s.cohort} • Issued {s.issuedAt}</div>
                  </button>
                ))}
              </div>
            )}
          </div>
        )}
        {/* Preflight status */}
        <div className="mb-3 text-xs text-gray-300 bg-gray-900/60 border border-gray-700 rounded p-3">
          <div className="flex flex-wrap gap-3 items-center">
            <div><span className="text-gray-400">Selected:</span> {selectionCount}</div>
            <div><span className="text-gray-400">Missing attachments:</span> {missingAttachments.length}</div>
            <div><span className="text-gray-400">Throttle est.:</span> {selectionCount} emails ≈ {estimatedDays} day{estimatedDays === 1 ? "" : "s"} at {dailyCap}/day</div>
            {sending && <div className="text-yellow-400">Sending...</div>}
            {lastResult && <div className="text-green-400">{lastResult}</div>}
            {!hasSubject && <div className="text-red-400">Subject required</div>}
            {!hasBody && <div className="text-red-400">Body required</div>}
            {missingAttachments.length > 0 && <div className="text-yellow-400">Attach files for all selected rows</div>}
          </div>
        </div>
        {/* Send controls */}
        <div className="mb-4 flex flex-wrap gap-2">
          <button
            className="px-3 py-2 bg-gray-700 rounded hover:bg-gray-600 text-sm"
            onClick={() => {
              // Demo: show preview alert for first selected recipient
              const sample = selectedList[0];
              if (!sample) return;
              const sampleCode = generateCertificateCode({ companyPrefix: AURORA_PREFIX, cohort: sample.cohort, fullName: sample.name, issuedAt: new Date(`${sample.issuedAt}T00:00:00Z`), seq: sample.seq });
              const rendered = body
                .replace(/\{\{name\}\}/g, sample.name)
                .replace(/\{\{cohort\}\}/g, sample.cohort)
                .replace(/\{\{cert_code\}\}/g, sampleCode);
              alert(`Test to: ${sample.email}\n\nSubject: ${subject}\n\n${rendered}`);
            }}
            disabled={selectionCount === 0}
          >Send Test</button>
          <button
            className="px-3 py-2 bg-gray-700 rounded hover:bg-gray-600 text-sm flex items-center gap-1"
            onClick={() => {
              navigator.clipboard.writeText(body);
              alert('Template copied to clipboard!');
            }}
            title="Copy email template to clipboard"
          >
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
            Copy Template
          </button>
          <button
            className={`px-3 py-2 rounded text-sm ${canSend ? "bg-[#CCFF00] text-black" : "bg-gray-700 text-gray-400 cursor-not-allowed"}`}
            onClick={() => { if (canSend) void sendRecipients(selectedList); }}
            disabled={!canSend || sending}
          >{sending ? "Sending..." : (recipientMode === "bulk" ? "Send Selected" : "Send Now")}</button>
        </div>
        <div className="grid grid-cols-1 gap-3">
          <div>
            <label className="block text-sm mb-1">Subject</label>
            <input
              className="w-full bg-gray-700 rounded px-3 py-2"
              value={subject}
              onChange={(e) => setSubject(e.target.value)}
              placeholder="Your Aurora Certificate"
            />
          </div>
          <div>
            <label className="block text-sm mb-1">Body</label>
            <textarea
              className="w-full bg-gray-700 rounded px-3 py-2 h-40"
              value={body}
              onChange={(e) => setBody(e.target.value)}
              placeholder="Dear {{name}}, ..."
            />
            <p className="text-xs text-gray-400 mt-1">
              Variables: <code className="bg-gray-900/60 px-1 rounded">{'{{name}}'}</code>,
              {' '}<code className="bg-gray-900/60 px-1 rounded">{'{{position}}'}</code>,
              {' '}<code className="bg-gray-900/60 px-1 rounded">{'{{cohort}}'}</code>,
              {' '}<code className="bg-gray-900/60 px-1 rounded">{'{{cert_code}}'}</code>,
              {' '}<code className="bg-gray-900/60 px-1 rounded">{'{{verify_url}}'}</code>
            </p>
          </div>
        </div>
      </section>

      <section className="mt-6 bg-gray-800 p-4 rounded-lg border border-gray-700">
        <h2 className="text-lg font-semibold mb-3">Certificates</h2>
        <div className="mb-3 flex items-center justify-between gap-2">
          <div className="text-xs text-gray-400">Page {page} of {totalPages} • {selectedList.length} rows</div>
          <div className="flex items-center gap-2">
            <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => setPage((p) => Math.max(1, p - 1))} disabled={page <= 1}>Prev</button>
            <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => setPage((p) => Math.min(totalPages, p + 1))} disabled={page >= totalPages}>Next</button>
            <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => downloadPdf()}>Download PDF (Page)</button>
            <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => downloadPdfAll()}>Download PDF (All)</button>
          </div>
        </div>
        <div ref={tableRef} className="overflow-auto">
          <table className="min-w-full text-xs md:text-sm">
            <thead>
              <tr className="text-left text-gray-300">
                <th className="py-1 pr-3">#</th>
                <th className="py-1 pr-3">Name</th>
                <th className="py-1 pr-3">Email</th>
                <th className="py-1 pr-3 hidden md:table-cell">Position</th>
                <th className="py-1 pr-3">Cohort</th>
                <th className="py-1 pr-3">Code</th>
                <th className="py-1 pr-3">Issued</th>
                <th className="py-1 pr-3 hidden sm:table-cell">Status</th>
                <th className="py-1 pr-3 hidden sm:table-cell">File</th>
                <th className="py-1 pr-3">Sent</th>
                <th className="py-1 pr-3">Actions</th>
              </tr>
            </thead>
            <tbody>
              {pageItems.map((s, idx) => {
                const sCode = (() => {
                  try {
                    return generateCertificateCode({ companyPrefix: AURORA_PREFIX, cohort: s.cohort, fullName: s.name, issuedAt: new Date(`${s.issuedAt}T00:00:00Z`), seq: s.seq });
                  } catch {
                    return "";
                  }
                })();
                const rank = pageStart + idx + 1;
                return (
                  <tr key={s.id} className="border-t border-gray-700/70">
                    <td className="py-1.5 pr-3 text-gray-400">{rank}</td>
                    <td className="py-1.5 pr-3">{editingId === s.id ? (
                      <input className="w-full bg-gray-700 rounded px-2 py-1" value={editDraft?.name ?? s.name} onChange={(e) => setEditDraft((d) => ({ ...(d ?? s), name: e.target.value }))} />
                    ) : s.name}</td>
                    <td className="py-1.5 pr-3 max-w-[180px] md:max-w-[240px] truncate">{editingId === s.id ? (
                      <input className="w-full bg-gray-700 rounded px-2 py-1" value={editDraft?.email ?? s.email} onChange={(e) => setEditDraft((d) => ({ ...(d ?? s), email: e.target.value }))} />
                    ) : s.email}</td>
                    <td className="py-1.5 pr-3 hidden md:table-cell">{editingId === s.id ? (
                      <input className="w-full bg-gray-700 rounded px-2 py-1" value={editDraft?.position ?? s.position} onChange={(e) => setEditDraft((d) => ({ ...(d ?? s), position: e.target.value }))} />
                    ) : s.position}</td>
                    <td className="py-1.5 pr-3">{editingId === s.id ? (
                      <input className="w-full bg-gray-700 rounded px-2 py-1" value={editDraft?.cohort ?? s.cohort} onChange={(e) => setEditDraft((d) => ({ ...(d ?? s), cohort: e.target.value }))} />
                    ) : s.cohort}</td>
                    <td className="py-1.5 pr-3 font-mono whitespace-nowrap">
                      <button className="underline decoration-dotted hover:opacity-80 text-[11px] md:text-xs" onClick={() => void navigator.clipboard.writeText(sCode)} title="Click to copy code">{sCode}</button>
                    </td>
                    <td className="py-1.5 pr-3">{editingId === s.id ? (
                      <input type="date" className="w-full bg-gray-700 rounded px-2 py-1" value={editDraft?.issuedAt ?? s.issuedAt} onChange={(e) => setEditDraft((d) => ({ ...(d ?? s), issuedAt: e.target.value }))} />
                    ) : s.issuedAt}</td>
                    <td className={`py-1.5 pr-3 hidden sm:table-cell capitalize ${s.status === 'suspended' ? 'text-red-400' : ''}`}>{s.status}</td>
                    <td className="py-1.5 pr-3 hidden sm:table-cell text-gray-200">
                      <div
                        className={`flex items-center gap-2 bg-gray-700 rounded p-2 border ${dragOverId === s.id ? 'border-[#CCFF00] ring-1 ring-[#CCFF00]' : 'border-gray-600'}`}
                        onDragOver={(e) => { e.preventDefault(); if (dragOverId !== s.id) setDragOverId(s.id); }}
                        onDragLeave={() => { if (dragOverId === s.id) setDragOverId(null); }}
                        onDrop={(e) => {
                          e.preventDefault();
                          const f = e.dataTransfer?.files?.[0];
                          if (f) {
                            setFilesById(prev => ({ ...prev, [s.id]: f }));
                            setFileName(f.name);
                          }
                          setDragOverId(null);
                        }}
                      >
                        <div className="relative">
                          {/* Visible URL field (read-only) that triggers hidden file input */}
                          <input
                            type="text"
                            readOnly
                            value={s.fileUrl || ''}
                            placeholder="No certificate yet. Click to upload."
                            className="block w-full text-xs bg-gray-800 rounded px-2 py-1 cursor-pointer placeholder:text-gray-500"
                            onClick={() => {
                              const el = document.getElementById(`hidden-file-${s.id}`) as HTMLInputElement | null;
                              el?.click();
                            }}
                          />
                          {/* Hidden file input for actual file selection and auto-upload */}
                          <input
                            id={`hidden-file-${s.id}`}
                            key={`file-input-${s.id}-${fileInputKeys[s.id] || 0}`}
                            type="file"
                            className="hidden"
                            accept="application/pdf,image/jpeg,image/png,image/gif,image/webp"
                            onChange={async (e) => {
                              const f = e.target.files?.[0];
                              if (!f) return;
                              try {
                                const fd = new FormData();
                                fd.append('studentId', s.id);
                                if (s.cohort) fd.append('cohort', s.cohort);
                                if (s.issuedAt) fd.append('issuedAt', s.issuedAt);
                                fd.append('file', f);
                                const resp = await fetch('/api/certificates/file/upload', { method: 'POST', body: fd });
                                const json = await resp.json();
                                if (!resp.ok) { toast(json?.error || 'Upload failed', 'error'); return; }
                                toast('File uploaded', 'success');
                                // refresh students so s.fileUrl shows the new URL
                                await fetchStudents();
                                // reset file input so re-selecting same file triggers onChange
                                const inputEl = e.target as HTMLInputElement | null;
                                if (inputEl) {
                                  try { inputEl.value = ''; } catch {}
                                }
                                clearFileInputState(s.id);
                              } catch (err) {
                                const msg = typeof err === 'object' && err && 'message' in err ? String((err as {message:unknown}).message) : String(err);
                                toast(`Upload error: ${msg}`, 'error');
                              }
                            }}
                          />
                        </div>
                      </div>
                      {(filesById[s.id]?.name || fileNames[s.id] || s.fileUrl) && (
                        <div className="text-xs text-gray-400 mt-1">
                          {filesById[s.id]?.name || (s.fileUrl && new URL(s.fileUrl).pathname.split('/').pop()) || ''}
                        </div>
                      )}
                      {s.fileUrl && (
                        <div className="text-xs text-gray-300 mt-1">
                          Stored: <a className="underline" href={s.fileUrl} target="_blank" rel="noreferrer">View</a>
                        </div>
                      )}
                      <div className="mt-2 flex flex-wrap gap-2">
                        {/* Upload button removed: upload happens automatically on file choose via the hidden input */}
                        <button
                          className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-[11px] disabled:opacity-50"
                          disabled={!s.fileUrl}
                          onClick={async () => {
                            if (!s.fileUrl) return;
                            if (!confirm('Delete stored file?')) return;
                            try {
                              const resp = await fetch('/api/certificates/file/delete', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ studentId: s.id, fileUrl: s.fileUrl }),
                              });
                              const json = await resp.json();
                              if (!resp.ok) { toast(json?.error || 'Delete failed', 'error'); return; }
                              toast('File deleted', 'success');
                              await fetchStudents();
                              clearFileInputState(s.id);
                            } catch (e) {
                              const msg = typeof e === 'object' && e && 'message' in e ? String((e as {message:unknown}).message) : String(e);
                              toast(`Delete error: ${msg}`, 'error');
                            }
                          }}
                        >Delete File</button>
                      </div>
                    </td>
                    <td className="py-1.5 pr-3">
                      {(() => {
                        const st = statusesById[s.id] ?? "pending";
                        if (st === "sent") return <span className="text-green-400">Sent</span>;
                        if (st === "failed") return <span className="text-red-400" title={errorsById[s.id] || ""}>Failed</span>;
                        return <span className="text-gray-400">Pending</span>;
                      })()}
                    </td>
                    <td className="py-1.5 pr-3">
                      {editingId === s.id ? (
                        <div className="flex gap-1.5">
                          <button className="px-2 py-0.5 bg-[#CCFF00] text-black rounded text-[11px]" onClick={saveEdit}>Save</button>
                          <button className="px-2 py-0.5 bg-gray-700 rounded hover:bg-gray-600 text-[11px]" onClick={cancelEdit}>Cancel</button>
                        </div>
                      ) : (
                        <div className="inline-block">
                          <button className="px-2 py-0.5 bg-gray-700 rounded hover:bg-gray-600 text-[11px] row-actions" onClick={() => toggleMenu(s.id)}>Actions ▾</button>
                        </div>
                      )}
                    </td>
                  </tr>
                );
              })}
              {recipientMode === "single" && !selectedSingle && (
                <tr className="border-t border-gray-700/70">
                  <td colSpan={11} className="py-6 text-center text-gray-400">Search and select a recipient to preview here.</td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
        <div className="mt-3 flex items-center justify-between gap-2">
          <div className="text-xs text-gray-400">Showing {pageStart + 1}-{Math.min(pageStart + PAGE_SIZE, selectedList.length)} of {selectedList.length}</div>
          <div className="flex items-center gap-2">
            <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => setPage((p) => Math.max(1, p - 1))} disabled={page <= 1}>Prev</button>
            <button className="px-2 py-1 bg-gray-700 rounded hover:bg-gray-600 text-xs" onClick={() => setPage((p) => Math.min(totalPages, p + 1))} disabled={page >= totalPages}>Next</button>
          </div>
        </div>
      </section>
      {/* Preview Modal */}
      {previewOpen && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
          <div className="w-full max-w-xl bg-gray-800 border border-gray-700 rounded-lg p-4">
            <div className="flex items-center justify-between mb-3">
              <h3 className="font-semibold">Preview</h3>
              <button className="text-gray-300 hover:text-white" onClick={() => setPreviewOpen(false)}>Close</button>
            </div>
            <div className="text-sm text-gray-400 mb-2">To: {previewTo}</div>
            <div className="mb-2">
              <label className="block text-sm mb-1 text-gray-300">Subject</label>
              <input
                className="w-full bg-gray-900 rounded px-3 py-2 text-sm"
                value={previewSubject}
                onChange={(e) => setPreviewSubject(e.target.value)}
              />
            </div>
            <div className="mb-3">
              <label className="block text-sm mb-1 text-gray-300">Body</label>
              <textarea
                className="w-full bg-gray-900 rounded px-3 py-2 text-sm h-56"
                value={previewBody}
                onChange={(e) => setPreviewBody(e.target.value)}
              />
            </div>
            <div className="flex justify-end gap-2">
              <button
                className="px-3 py-2 bg-gray-700 rounded hover:bg-gray-600 text-sm"
                onClick={() => setPreviewOpen(false)}
              >Cancel</button>
              <button
                className="px-3 py-2 bg-[#CCFF00] text-black rounded text-sm"
                onClick={() => { setSubject(previewSubject); setPreviewOpen(false); }}
              >Save Changes</button>
            </div>
          </div>
        </div>
      )}
      {/* Toast UI */}
      <div className="fixed top-3 right-3 z-50 space-y-2">
        {toasts.map((t) => (
          <div key={t.id} className={`px-3 py-2 rounded text-sm shadow border ${t.type === 'success' ? 'bg-green-700/80 border-green-500' : t.type === 'error' ? 'bg-red-700/80 border-red-500' : 'bg-gray-700/80 border-gray-500'}`}>
            {t.text}
          </div>
        ))}
      </div>
      {/* Centered actions modal */}
      {openMenuId && openMenuRow && (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 bg-black/50" />
          <div id="actions-popover" className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[280px] max-w-[92vw] bg-gray-900 border border-gray-700 rounded-lg shadow-2xl">
            <div className="px-4 py-3 border-b border-gray-800 flex items-center justify-between">
              <div className="text-sm text-gray-300">Actions</div>
              <button className="text-gray-400 hover:text-white" onClick={() => setOpenMenuId(null)}>✕</button>
            </div>
            <div className="py-1">
              <button className="w-full text-left px-4 py-2 hover:bg-gray-800 text-[13px]" onClick={() => { void copyCode(openMenuRow); setOpenMenuId(null); }}>Copy Code</button>
              <button className="w-full text-left px-4 py-2 hover:bg-gray-800 text-[13px]" onClick={() => { openPreview(openMenuRow); setOpenMenuId(null); }}>Preview</button>
              <button className="w-full text-left px-4 py-2 hover:bg-gray-800 text-[13px]" onClick={() => { startEdit(openMenuRow.id); setOpenMenuId(null); }}>Edit</button>
              <button className="w-full text-left px-4 py-2 hover:bg-gray-800 text-[13px]" onClick={() => { toggleSuspend(openMenuRow.id); setOpenMenuId(null); }}>{openMenuRow.status === 'suspended' ? 'Unsuspend' : 'Suspend'}</button>
              <button className="w-full text-left px-4 py-2 hover:bg-gray-800 text-[13px] text-red-300" onClick={() => { void deleteRow(openMenuRow.id); setOpenMenuId(null); }}>Delete</button>
              <button
                className="w-full text-left px-4 py-2 hover:bg-gray-800 text-[13px]"
                onClick={() => {
                  if (sending) return;
                  if (!filesById[openMenuRow.id] && !openMenuRow.fileUrl) {
                    toast("Please attach a file to this row before sending.", "error");
                    return;
                  }
                  void sendRecipients([openMenuRow]);
                  setOpenMenuId(null);
                }}
              >Send Email</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
